/*
Navicat MySQL Data Transfer

Source Server         : root
Source Server Version : 50724
Source Host           : localhost:3306
Source Database       : csaplat2

Target Server Type    : MYSQL
Target Server Version : 50724
File Encoding         : 65001

Date: 2020-05-13 18:26:00
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for `boke_boke`
-- ----------------------------
DROP TABLE IF EXISTS `boke_boke`;
CREATE TABLE `boke_boke` (
  `boke_id` varchar(32) NOT NULL,
  `boke_subtitle` varchar(40) DEFAULT NULL,
  `boke_type` varchar(40) DEFAULT NULL,
  `boke_title` char(40) DEFAULT NULL,
  `boke_code` varchar(40) DEFAULT NULL,
  `creater` varchar(40) DEFAULT NULL,
  `createtime` bigint(20) DEFAULT NULL,
  `isdel` varchar(40) DEFAULT NULL,
  `version` varchar(40) DEFAULT NULL,
  `info` text,
  `collect_num` int(11) DEFAULT NULL,
  `state` varchar(40) DEFAULT NULL,
  `picture_code` varchar(40) DEFAULT NULL COMMENT '关联图片code',
  `path` varchar(500) DEFAULT NULL COMMENT '封面路径',
  `admin_code` varchar(40) DEFAULT NULL,
  `modtime` bigint(20) DEFAULT NULL,
  `submittime` bigint(20) DEFAULT NULL,
  `ispublic` varchar(40) DEFAULT NULL,
  `cover` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`boke_id`),
  UNIQUE KEY `code` (`boke_code`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of boke_boke
-- ----------------------------
INSERT INTO `boke_boke` VALUES ('04d74279484842f38dac399f5a95304a', 'Android的Drawable分类和使用详解', 'a663fea74fce46cb899e29cb5fa54685', 'Android的Drawable分类和使用详解', 'BOKE202004281989', 'a8d54e799fa04d4f9f5f8d795638d2bd', '1588053444622', '0', '0', '<p>一、前言<br />\n最近在看关于Android的书籍，发现居然把Drawable当做一个章节来讲，感觉没有必要啊，Drawable不就是图片引用吗。深入理解后才发现我们平常用的只是比较常用和简单的，Drawable还是有很多其他实现方式的。今天就详细讲解一下Drawable。</p>\n\n<p>二、概述<br />\n其实Drawable的种类有很多，常见的有BitmapDrawable、ShapeDrawable、LayerDrawable、StateListDrawable。下面详细讲解一下Drawable的各个使用方式</p>\n\n<p>1、BitmapDrawable<br />\n开发中基本不使用，因为我们在控件调用图片时直接通过src或者background的方式就直接引用图片了，而bitmapDrawable是对图片进行重新描述和定义，如果图片没有特殊情况不会多此一举的，下面讲一下具体用法。</p>\n\n<p>Drawable 下新建bitmap.xml：是对需要的图片进行重新定义</p>\n\n<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br />\n&lt;bitmap xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;<br />\n&nbsp; &nbsp; android:src=&quot;@drawable/material_item_background&quot;<br />\n&nbsp; &nbsp; android:tileMode=&quot;mirror&quot;<br />\n&nbsp; &nbsp; android:antialias=&quot;true&quot;<br />\n&nbsp; &nbsp; android:filter=&quot;true&quot;<br />\n&nbsp; &nbsp; android:dither=&quot;true&quot;&gt;<br />\n&lt;/bitmap&gt;<br />\n（1）android:antialias：表示是否开启抗锯齿功能，一般为true；</p>\n\n<p>（2）android:dither：表示是否开启抖动，一般为true；</p>\n\n<p>（3）android:filter：表示是否开启过滤效果，一般为true；</p>\n\n<p>（4）android:tileMode：表示是否平铺模式 ，disable默认不平铺；repeat表示水平和竖直方向的平铺；mirror表示水平和竖&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直方向的镜面投影效果，clamp表示四周图像会扩展到周围区域。</p>\n\n<p>使用自定义的bitmap方式</p>\n\n<p>&nbsp; &nbsp; &lt;ImageView<br />\n&nbsp; &nbsp; &nbsp; &nbsp; android:layout_width=&quot;wrap_content&quot;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; android:src=&quot;@drawable/my_bitmap&quot;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; android:layout_height=&quot;wrap_content&quot; /&gt;<br />\n2、ShapeDrawable<br />\nShapeDrawable可以实现矩形、圆形、线和圆环；它既可以是纯色的图形，也可以是渐变色的图形</p>\n\n<p>（1）代码效果图如下</p>\n\n<p>&nbsp;</p>\n', '0', '0', null, null, null, '1588228978223', '0', '1', null);
INSERT INTO `boke_boke` VALUES ('2eaf82c9fd5646aa816939910e6d7c2a', '软件版本GA、RC、beta等含义', '645b5b81d6ce4f6b9a74ea8a7179bc35', '软件版本GA、RC、beta等含义', 'BOKE202004282671', 'a8d54e799fa04d4f9f5f8d795638d2bd', '1588063790553', '0', '0', '<p><img alt=\"\" src=\"http://imgs/USER202004270057/b18b1eff07c44efba966c61ba9bb18e7.jpg\" style=\"height:225px; width:400px\" /></p>\n\n<p>GA<br />\nGeneral Availability，正式发布的版本，官方开始推荐广泛使用，国外有的用GA来表示release版本。</p>\n\n<p>RELEASE<br />\n正式发布版，官方推荐使用的版本，有的用GA来表示。比如spring。</p>\n\n<p>Stable<br />\n稳定版，开源软件有的会用stable来表示正式发布的版本。比如Nginx。</p>\n\n<p>Final<br />\n最终版，也是正式发布版的一种表示方法。比如Hibernate。</p>\n\n<p>RC<br />\nRelease Candidate，发行候选版本，基本不再加入新的功能，主要修复bug。是最终发布成正式版的前一个版本，将bug修改完就可以发布成正式版了。</p>\n\n<p>alpha<br />\n&alpha;是希腊字母的第一个，表示最早的版本，内部测试版，一般不向外部发布，bug会比较多，功能也不全，一般只有测试人员使用。</p>\n\n<p>Beta<br />\n&beta;是希腊字母的第二个，公开测试版，比alpha版本晚些，主要会有&ldquo;粉丝用户&rdquo;测试使用，该版本仍然存在很多bug，但比alpha版本稳定一些。这个阶段版本还会不断增加新功能。分为Beta1、Beta2等，直到逐渐稳定下来进入RC版本。</p>\n\n<p>番外篇<br />\n####授权和功能划分：<br />\nTrial：试用版，通常都有时间限制，有些试用版软件还在功能上做了一定的限制。可注册或购买成为正式版<br />\nUnregistered：未注册版，通常没有时间限制，在功能上相对于正式版做了一定的限制。可注册或购买成为正式版。<br />\nDemo：演示版，仅仅集成了正式版中的几个功能，不能升级成正式版。<br />\nLite：精简版。<br />\nFull　version：完整版，属于正式版。</p>\n\n<p>其他版本<br />\nEnhance　：增强版或者加强版　属于正式版1<br />\nFree　：自由版<br />\nRelease　：发行版　有时间限制<br />\nUpgrade　：升级版<br />\nRetail　　：零售版<br />\nCardware　：属共享软件的一种，只要给作者回复一封电邮或明信片即可。（有的作者并由此提供注册码等），目前这种形式已不多见。/　S<br />\nPlus　：属增强版，不过这种大部分是在程序界面及多媒体功能上增强。<br />\nPreview　：预览版<br />\nCorporation　&amp;　Enterprise　：企业版<br />\nStandard　：标准版<br />\nMini　：迷你版也叫精简版只有最基本的功能<br />\nPremium　：　贵价版<br />\nProfessional(Pro)　：　专业版<br />\nExpress　：　特别版<br />\nDeluxe　：　豪华版<br />\nRegged　：　已注册版</p>\n\n<p>Build:内部标号<br />\nDelux:豪华版 (deluxe: 豪华的，华丽的)<br />\nDEMO演示版，一般会有功能限制<br />\nFull:完全版<br />\nPlus:加强版<br />\nTrial:试用版（一般有时间或者功能限制）<br />\n&nbsp;</p>\n', '0', '0', null, null, null, '1589161898479', '0', '0', null);
INSERT INTO `boke_boke` VALUES ('33371b68bc9f49919e13cb853d44edb6', '', null, 'RxJava2.0——从放弃到入门', 'BOKE202004283562', 'a8d54e799fa04d4f9f5f8d795638d2bd', '1588045159667', '0', '0', '<h2>学习RxJava2.0之前需不需要学习RxJava1.0</h2>\n\n<p>首先，RxJava1.0和RxJava2.0的核心思想都是观察者模式，只不过RxJava2.0在RxJava1.0的基础对一些方法进行了优化，方便于开发者更好地理解其编程思想，同时又增加了一部分新的方法解决1.0存在的问题，例如背压等。所以，如果你学习过RxJava1.0那么很好，你可能已经理解了什么是观察者模式；如果你没有学过RxJava1.0，当然也不必着急，因为本文将从最基本的观察者模式讲起，让你从最基本最简单的角度入手RxJava。综上所述，不管你是不是学过RxJava1.0,都不会影响你学习本篇文章。</p>\n\n<h2>观察者模式</h2>\n\n<p>在学习RxJava2.0之前，我们必须要弄明白什么是观察者模式。按照我的惯例，先上一个百度百科的权威介绍</p>\n\n<p>&nbsp;</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/2477378-2db61919b38518c8.png?imageMogr2/auto-orient/strip|imageView2/2/w/853/format/webp\" /></p>\n\n<p>百度百科的观察者模式介绍</p>\n\n<p>简单介绍一下，A和B两个，A是被观察者，B是观察者，B对A进行观察，B并不是需要时刻盯着A，而是A如果发生了变化，会主动通知B，B会对应做一些变化。举个例子，假设A是连载小说，B是读者，读者订阅了连载小说，当小说出现了新的连载的时候，会推送给读者。读者不用时刻盯着小说连载，而小说有了新的连载会主动推送给读者。这就是观察者模式。而RxJava正是基于观察者模式开发的。</p>\n\n<p>&nbsp;</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/2477378-f669ac4450113faf.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp\" /></p>\n\n<p>观察者模式.png</p>\n\n<h2>RxJava2.0的基本使用</h2>\n\n<p>理解好了观察者模式，我们开始RxJava2.0的学习。首先引入RxJava2.0相关的类库。<br />\ncompile &#39;io.reactivex.rxjava2:rxjava:2.0.1&#39;</p>\n\n<p>compile &#39;io.reactivex.rxjava2:rxandroid:2.0.1&#39;</p>\n\n<p>正确使用姿势：</p>\n\n<p>第一步：创建连载小说（被观察者）</p>\n\n<p>&nbsp;</p>\n\n<pre>\n<code>//被观察者\n        Observable novel=Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n            @Override\n            public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception {\n                emitter.onNext(&quot;连载1&quot;);\n                emitter.onNext(&quot;连载2&quot;);\n                emitter.onNext(&quot;连载3&quot;);\n                emitter.onComplete();\n            }\n        });\n</code></pre>\n\n<p>Observable中文意思就是被观察者，通过create方法生成对象，里面放的参数ObservableOnSubscribe&lt;T&gt;，可以理解为一个计划表，泛型T是要操作对象的类型，重写subscribe方法，里面写具体的计划，本文的例子就是推送连载1、连载2和连载3，在subscribe中的ObservableEmitter&lt;String&gt;对象的Emitter是发射器的意思。ObservableEmitter有三种发射的方法，分别是void onNext(T value)、void onError(Throwable error)、void onComplete()，onNext方法可以无限调用，Observer（观察者）所有的都能接收到，onError和onComplete是互斥的，Observer（观察者）只能接收到一个，OnComplete可以重复调用，但是Observer（观察者）只会接收一次，而onError不可以重复调用，第二次调用就会报异常。</p>\n\n<p>第二步：创建读者（观察者）</p>\n\n<p>&nbsp;</p>\n\n<pre>\n<code>//观察者\n        Observer&lt;String&gt; reader=new Observer&lt;String&gt;() {\n            @Override\n            public void onSubscribe(Disposable d) {\n                mDisposable=d;\n                Log.e(TAG,&quot;onSubscribe&quot;);\n            }\n\n            @Override\n            public void onNext(String value) {\n                if (&quot;2&quot;.equals(value)){\n                    mDisposable.dispose();\n                    return;\n                }\n                Log.e(TAG,&quot;onNext:&quot;+value);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                Log.e(TAG,&quot;onError=&quot;+e.getMessage());\n            }\n\n            @Override\n            public void onComplete() {\n                Log.e(TAG,&quot;onComplete()&quot;);\n            }\n        };\n</code></pre>\n\n<p>通过new创建接口，并实现其内部的方法，看方法其实就应该差不多知道干嘛的，onNext、onError、onComplete都是跟被观察者发射的方法一一对应的，这里就相当于接收了。onSubscribe（Disposable d）里面的Disposable对象要说一下，Disposable英文意思是可随意使用的，这里就相当于读者和连载小说的订阅关系，如果读者不想再订阅该小说了，可以调用 mDisposable.dispose()取消订阅，此时连载小说更新的时候就不会再推送给读者了。</p>\n\n<p>第三步：读者和连载小说建立订阅关系</p>\n\n<p>&nbsp;</p>\n\n<pre>\n<code>novel.subscribe(reader);//一行代码搞定\n</code></pre>\n\n<p>在这里细心的你，可能已经发现了怎么是小说订阅了读者，之所以这样，是因为RxJava主要是想保持自己的链式编程，不得不把Observable(被观察者)放在前面,这里大家可以理解为小说被读者订阅了。</p>\n\n<p>这里我们先看一下输出效果</p>\n\n<p>&nbsp;</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/2477378-5e6e7d84e209fae3.png?imageMogr2/auto-orient/strip|imageView2/2/w/851/format/webp\" /></p>\n\n<p>输出效果</p>\n\n<p>小结一下：这就是RxJava2.0最最简单的用法，创建小说，创建读者，建立订阅关系，记住这三步，你就能实现一个最简单的RxJava2.0的用法。</p>\n\n<h2>RxJava2.0的异步和链式编程</h2>\n\n<p>前言里面有提到，RxJava是支持异步的，但是RxJava是如何做到的呢？这里就需要Scheduler。Scheduler，英文名调度器，它是RxJava用来控制线程。当我们没有设置的时候，RxJava遵循哪个线程产生就在哪个线程消费的原则，也就是说线程不会产生变化，始终在同一个。然后我们一般使用RxJava都是后台执行，前台调用，本着这个原则，我们需要调用observeOn(AndroidSchedulers.mainThread())，observeOn是事件回调的线程，AndroidSchedulers.mainThread()一看就知道是主线程，subscribeOn(Schedulers.io())，subscribeOn是事件执行的线程，Schedulers.io()是子线程，这里也可以用Schedulers.newThread()，只不过io线程可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。前面的代码根据异步和链式编程的原则，我们可以写成</p>\n\n<p>&nbsp;</p>\n\n<pre>\n<code> Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n            @Override\n            public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception {\n                emitter.onNext(&quot;连载1&quot;);\n                emitter.onNext(&quot;连载2&quot;);\n                emitter.onNext(&quot;连载3&quot;);\n                emitter.onComplete();\n            }\n        })\n                .observeOn(AndroidSchedulers.mainThread())//回调在主线程\n                .subscribeOn(Schedulers.io())//执行在io线程\n                .subscribe(new Observer&lt;String&gt;() {\n                    @Override\n                    public void onSubscribe(Disposable d) {\n                        Log.e(TAG,&quot;onSubscribe&quot;);\n                    }\n\n                    @Override\n                    public void onNext(String value) {\n                        Log.e(TAG,&quot;onNext:&quot;+value);\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                        Log.e(TAG,&quot;onError=&quot;+e.getMessage());\n                    }\n\n                    @Override\n                    public void onComplete() {\n                        Log.e(TAG,&quot;onComplete()&quot;);\n                    }\n                });\n</code></pre>\n\n<p>这里就是RxJava最常用的写法，异步+链式编程，还要再说一下，subscribe的方法重载，subscribe（）方法里什么参数也不放是空实现，也就是说连载小说无论出什么连载，读者都不关心，推送过来了也不读，如果读者只关心onNext方法里的内容，可以直接重载subscribe(Consumer&lt;? spuer T&gt; onNext)这个方法，会减少代码，当然如果是初学者还是建议创建Observer对象。</p>\n\n<p>&nbsp;</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/2477378-c4c78f5282c3d520.png?imageMogr2/auto-orient/strip|imageView2/2/w/1127/format/webp\" /></p>\n\n<p>subscrib的方法重载</p>\n\n<h2>应用场景</h2>\n\n<p>说了这么多RxJava2.0的用法，你一定要问了到底在什么情况下使用？下面先给大家介绍一下典型的场景。<br />\n一、与Retrofit联用<br />\nRetrofit+RxJava的上网模式已经非常火了，如果有不了解的可以看笔者的这篇文章<a href=\"https://www.jianshu.com/writer#/notebooks/5118090/notes/25405151\" target=\"_blank\">https://www.jianshu.com/writer#/notebooks/5118090/notes/25405151</a><br />\n二、Rxpermissions等类库的使用<br />\n基于RxJava的开源类库Rxpermissions、RxBinding以及RxBus在很多项目中已经非常常见，并且被证明了是极其好用的。<br />\n三、所有用到异步的地方<br />\n因为RxJava就是一个支持异步的链式编程，所以所有的用到异步的地方，我们都可以用RxJava来完成，下面给大家举几个例子。<br />\n定时执行任务</p>\n\n<p>&nbsp;</p>\n\n<pre>\n<code> Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {\n            @Override\n            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {\n                emitter.onNext(123);\n                sleep(3000);\n                emitter.onNext(456);\n            }\n        }).observeOn(AndroidSchedulers.mainThread())\n                .subscribeOn(Schedulers.io())\n                .subscribe(new Consumer&lt;Integer&gt;() {\n                    @Override\n                    public void accept(Integer integer) throws Exception {\n                        Log.e(TAG,integer+&quot;&quot;);\n                    }\n                }, new Consumer&lt;Throwable&gt;() {\n                    @Override\n                    public void accept(Throwable throwable) throws Exception {\n\n                    }\n                }, new Action() {\n                    @Override\n                    public void run() throws Exception {\n\n                    }\n                });\n</code></pre>\n\n<p>看完上面的代码你肯定在想，这么多代码，干嘛不直接new Handler().postDelayed()。如果你的程序线程里面做的操作很简单，那么你用new Handler().postDelayed()无所谓，但是如果你的操作很复杂，那么这时候就体现出了RxJava的好处了，借用扔物线大神的一句话就是&quot;随着程序逻辑变得越来越复杂，RxJava依然能够保持简洁&quot;。<br />\n下面来说一个复杂的操作，比如我们要依次加载10张图片（加载图片是耗时过程），其中第六张我们延时3秒加载，第7张我们复制到sd卡里，第8张我们要上网络，那么请问你要怎么做，如果用Handler，必然是各种嵌套，各种逻辑复杂得让你再看一眼都难受，但是如果使用RxJava呢？</p>\n\n<p>&nbsp;</p>\n\n<pre>\n<code>Observable.create(new ObservableOnSubscribe&lt;Drawable&gt;() {\n            @Override\n            public void subscribe(ObservableEmitter&lt;Drawable&gt; emitter) throws Exception {\n                for (int i=0;i&lt;drawableRes.length;i++){\n                    Drawable drawable=getResources().getDrawable(drawableRes[i]);\n                    //第6个图片延时3秒后架子\n                    if (i==5){\n                        sleep(3000);\n                    }\n                    //复制第7张图片到sd卡\n                    if (i==6){\n                        Bitmap bitmap=((BitmapDrawable)drawable).getBitmap();\n                        saveBitmap(bitmap,&quot;test.png&quot;, Bitmap.CompressFormat.PNG);\n                    }\n                    //上传到网络\n                    if (i==7){\n                        updateIcon(drawable);\n                    }\n                    emitter.onNext(drawable);\n                }\n            }\n        }).subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(new Consumer&lt;Drawable&gt;() {\n                    @Override\n                    public void accept(Drawable drawable) throws Exception {\n                           //回调后在UI界面上展示出来\n                    }\n                });\n</code></pre>\n\n<p>没有任何嵌套，逻辑依然简洁，这就是RxJava的好处。</p>\n\n<h2>总结</h2>\n\n<p>RxJava2.0是非常好用的一个异步链式库，遵循观察者模式。理解观察者模式可以根据连载小说和读者的关系，被观察者是连载小说，观察者是读者，读者订阅小说，当小说有了新的连载推送给读者，这就是观察者模式；创建RxJava最简单的步骤，一、创建被观察者对象，二、创建观者对象，三创建订阅关系；RxJava2.0的应用场景，只要记得一句话就是所有的异步都可以用RxJava来做就可以了，尤其是复杂的场景，越是复杂的场景越能体现RxJava的好处。关于RxJava的文章，笔者将会继续推出两篇，一篇是《RxJava从入门到进阶》讲的是RxJava的一些进阶操作，例如变换、常用操作符和背压；另一篇是RxJava相关的类库的介绍和使用，例如文章中提到的RxBinding、RxPerssions等等。如果喜欢笔者，可以关注一波，谢谢！</p>\n\n<p>最后放上我的github地址（本次demo的代码基本都在文章上了，不下也可以）：<a href=\"https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fkaka10xiaobang%2FRxJavaDemo\" target=\"_blank\">https://github.com/kaka10xiaobang/RxJavaDemo</a></p>\n\n<p><br />\n<br />\n作者：肖邦kaka<br />\n链接：https://www.jianshu.com/p/cd3557b1a474<br />\n来源：简书<br />\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n', '0', '0', null, null, null, '1588045482951', '0', '1', null);
INSERT INTO `boke_boke` VALUES ('3620f4acffc9467c9b37a0d0e1c03187', 'git 删除文件', null, 'git 删除文件', 'BOKE202004288408', 'a8d54e799fa04d4f9f5f8d795638d2bd', '1588052987565', '0', '0', '<blockquote>\n<h3>git删除文件包括以下几种情况</h3>\n</blockquote>\n\n<ol>\n	<li>删除本地文件，但是未添加到暂存区；</li>\n	<li>删除本地文件，并且把删除操作添加到了暂存区；</li>\n	<li>把暂存区的操作提交到了本地git库；</li>\n	<li>把本地git库的删除记录推送到了远程服务器github。</li>\n</ol>\n\n<blockquote>\n<p>git对于删除操作有极大的撤销空间，下面分别针对上面4种情况进行恢复操作。</p>\n</blockquote>\n\n<h3>一、删除了本地文件，但未添加到暂存区；</h3>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/1606281-3260df21882fdf94.png?imageMogr2/auto-orient/strip|imageView2/2/w/634/format/webp\" /></p>\n\n<p>选择要删除的文件12.md</p>\n\n<p>&nbsp;</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/1606281-8e26479a22bda8f6.png?imageMogr2/auto-orient/strip|imageView2/2/w/853/format/webp\" /></p>\n\n<p>删除本地文件12.md</p>\n\n<blockquote>\n<p>此时发现删除错误了要进行恢复操作</p>\n</blockquote>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/1606281-505c42bd31234a97.png?imageMogr2/auto-orient/strip|imageView2/2/w/853/format/webp\" /></p>\n\n<p>恢复文件</p>\n\n<h3>二、删除了本地文件，并且已经把删除操作添加到了暂存区</h3>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/1606281-3c84b57c65ca32f0.png?imageMogr2/auto-orient/strip|imageView2/2/w/853/format/webp\" /></p>\n\n<p>删除本地文件</p>\n\n<p>&nbsp;</p>\n\n<p>通过git status查看状态</p>\n\n<p>&nbsp;</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/1606281-3c16f83b565c6da0.png?imageMogr2/auto-orient/strip|imageView2/2/w/595/format/webp\" /></p>\n\n<p>查看删除状态</p>\n\n<p>&nbsp;</p>\n\n<p>看提示可以知道，此时如果操作 git checkout 12.md 可以恢复删除文件<br />\n如果操作 git add/rm 12.md 可以把删除状态添加到暂存区<br />\n我们进行添加操作</p>\n\n<p>&nbsp;</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/1606281-7095d2e295407ae4.png?imageMogr2/auto-orient/strip|imageView2/2/w/595/format/webp\" /></p>\n\n<p>添加到暂存区</p>\n\n<p><br />\n查看状态，可以知道删除操作已经被添加到了暂存区，</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/1606281-fc388ea8363e4d51.png?imageMogr2/auto-orient/strip|imageView2/2/w/595/format/webp\" /></p>\n\n<p>查看添加状态</p>\n\n<p><br />\n此时如果要撤销操作，从提示可以知道，进行 git reset HEAD 12.md可以把删除操作退回到本地删除状态，然后按照上面1的操作就可以恢复文件</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/1606281-5fd5546554a84787.png?imageMogr2/auto-orient/strip|imageView2/2/w/595/format/webp\" /></p>\n\n<p>从暂存区回滚</p>\n\n<p>&nbsp;</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/1606281-49b10d7c984ed899.png?imageMogr2/auto-orient/strip|imageView2/2/w/853/format/webp\" /></p>\n\n<p>恢复文件</p>\n\n<h3>三、从暂存区把删除操作提交到了本地git库</h3>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/1606281-3f72ca0ebac8e4de.png?imageMogr2/auto-orient/strip|imageView2/2/w/853/format/webp\" /></p>\n\n<p>提交删除操作</p>\n\n<p>&nbsp;</p>\n\n<p>查看状态 git status</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/1606281-72387f2c69c17e5d.png?imageMogr2/auto-orient/strip|imageView2/2/w/595/format/webp\" /></p>\n\n<p>查看删除状态</p>\n\n<p>可以看到有一个提交改动，此时如果要撤销，就必须对git进行版本回滚操作<br />\n通过 git log 命令查看git库的所有版本信息</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/1606281-276eb2b68df6c4fa.png?imageMogr2/auto-orient/strip|imageView2/2/w/683/format/webp\" /></p>\n\n<p>查看git库版本</p>\n\n<p>如果感觉信息太多，可以查看简洁log版本 输入 git log --pretty=oneline</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/1606281-e3df5afb4f5cf32d.png?imageMogr2/auto-orient/strip|imageView2/2/w/595/format/webp\" /></p>\n\n<p>简洁版log信息</p>\n\n<p>看到一大串类似 6aef622c4&hellip;&hellip;8445f2429f的用16进制表示的字符串是每次 commit 的ID版本号，此时我们进行版本回滚操作<br />\n选择ID的前几位字符串就足够表示版本的唯一性，输入命令 git reset --hard 6aef62</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/1606281-83617ca88a3f8a46.png?imageMogr2/auto-orient/strip|imageView2/2/w/595/format/webp\" /></p>\n\n<p>版本回滚</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/1606281-2815b7acbf08563d.png?imageMogr2/auto-orient/strip|imageView2/2/w/853/format/webp\" /></p>\n\n<p>查看本地文件恢复情况</p>\n\n<h3>四、如果删除操作已经推送到了远程github服务器中，可以通过 git push 操作来进行推送</h3>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/1606281-f0f8a7b12e7370b5.png?imageMogr2/auto-orient/strip|imageView2/2/w/683/format/webp\" /></p>\n\n<p>推送到远程服务器</p>\n\n<p>服务器刷新前的状态</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/1606281-23fcb3a121b702eb.png?imageMogr2/auto-orient/strip|imageView2/2/w/1017/format/webp\" /></p>\n\n<p>服务器刷新前的状态</p>\n\n<p>刷新服务器</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/1606281-856a0a9841c74248.png?imageMogr2/auto-orient/strip|imageView2/2/w/1012/format/webp\" /></p>\n\n<p>刷新服务器后的状态</p>\n\n<p>可以看到文件被从服务器中删除了，如果此时进行文件恢复操作就需要像上面第三步那样进行版本回滚操作<br />\n当然了，这个版本回滚是在本地进行的，然后把回滚后的版本提交</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/1606281-bbe2b8a7e39eddc9.png?imageMogr2/auto-orient/strip|imageView2/2/w/595/format/webp\" /></p>\n\n<p>git版本回滚</p>\n\n<p>把回滚后的版本提交到远程服务器 git push</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/1606281-6fcdfb0232b937cb.png?imageMogr2/auto-orient/strip|imageView2/2/w/683/format/webp\" /></p>\n\n<p>版本提交出错</p>\n\n<p>可以看到提交出错，因为git默认是高版本覆盖低版本，但不能反过来操作，因为回滚的版本比服务器此时的版本低，所以此时常规手段是无效的，但可以进行版本的暴力提交&mdash;&mdash;force<br />\n通过git的提示 git push -h 可以查看到 force的说明</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/1606281-1a92c7f207c35829.png?imageMogr2/auto-orient/strip|imageView2/2/w/683/format/webp\" /></p>\n\n<p>查看force的解释</p>\n\n<p>进行暴力提交 git push -f</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/1606281-227d07aa1bbe0bb6.png?imageMogr2/auto-orient/strip|imageView2/2/w/683/format/webp\" /></p>\n\n<p>暴力提交</p>\n\n<p>刷新github远程服务器刷新操作</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/1606281-96f1062db9d43086.png?imageMogr2/auto-orient/strip|imageView2/2/w/1024/format/webp\" /></p>\n\n<p>文件失而复得</p>\n\n<blockquote>\n<p>如果要在服务器中回到删除文件的高级git版本版本该怎么操作呢？</p>\n</blockquote>\n\n<ol>\n	<li>当然了，最简单的办法就是把费了老劲恢复的文件再次删除就可以，这样效果上是可以的，但是之前的那个git版本号其实是丢失了。</li>\n	<li>git中有一个命令 reflog 可以查看每次提交的信息，包括 commit ID和名称，可以通过提交信息找到之前的版本好，然后重新回滚就可以了。</li>\n</ol>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/1606281-4ec14840add3b7c9.png?imageMogr2/auto-orient/strip|imageView2/2/w/595/format/webp\" /></p>\n\n<p>查找commit ID</p>\n\n<p>进行回滚操作</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/1606281-d56ac0aecd226c23.png?imageMogr2/auto-orient/strip|imageView2/2/w/595/format/webp\" /></p>\n\n<p>版本回滚成功</p>\n\n<p>然后再进行暴力提交</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/1606281-b994f966b9afd3eb.png?imageMogr2/auto-orient/strip|imageView2/2/w/683/format/webp\" /></p>\n\n<p>暴力提交</p>\n\n<p>刷新github服务器</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/1606281-225fc3e81ef6ff53.png?imageMogr2/auto-orient/strip|imageView2/2/w/1002/format/webp\" /></p>\n\n<p>刷新服务器</p>\n\n<p><br />\n<br />\n作者：wmsj100<br />\n链接：https://www.jianshu.com/p/c3ff8f0da85e<br />\n来源：简书<br />\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n', '0', '0', null, null, null, '1589354188685', '0', '1', null);
INSERT INTO `boke_boke` VALUES ('394e83a4402d475f9e1e214098d3b230', 'MediaPlayer详解和使用', null, 'MediaPlayer详解和使用', 'BOKE202004284456', 'a8d54e799fa04d4f9f5f8d795638d2bd', '1588053326211', '0', '0', '<p>Android多媒体相关的API，网上基本都能找到很多相关的文章，使用起来也很简单，一直在犹豫要不要写这方面的内容，后来决定还是写一写，一方面算是一个归纳总结，另一方面，也方便以后查阅。这一篇就写一下MediaPlayer。</p>\n\n<p>状态图详解<br />\n下图是一个MediaPlayer的生命周期和状态。其中，椭圆代表MediaPlayer可能驻留的状态，弧线表示MediaPlayer的播放控制操作。这里有两种类型的弧线，单箭头弧线代表同步方法调用，双箭头弧线代表异步方法调用。&nbsp;</p>\n\n<p><br />\n1、新创建的MediaPlayer对象、或者调用了reset()方法的MediaPlayer对象，都处于Idle状态，这两种方法得到的对象，有一个微小但十分重要的差别。</p>\n\n<p>处于Idle状态时，调用 getCurrentPosition(), getDuration(), getVideoHeight(), getVideoWidth(), setAudioStreamType(), setLooping(), setVolume(), pause(), start(), stop(), seekTo(), prepare(), prepareAsync()方法都会报错。新创建的MediaPlayer对象，调用以上方法，无法接收到注册的OnErrorListener.onError()回调；调用reset()方法的MediaPlayer对象可以接收到回调。</p>\n\n<p>MediaPlayer不再被使用时，应立即调用release()方法来释放资源，资源可能包括硬件加速组件的单态固件，若没有调用release()方法可能会导致之后的MediaPlayer对象实例无法使用这种单态硬件资源，导致异常。</p>\n\n<p>一旦MediaPlayer对象进入了End状态，将不能再被使用，也没有办法再迁移到其他状态。</p>\n\n<p>2、由于种种原因，一些操作可能会失败，如不支持的格式/分辨率太高/流超时等，还有编程错误（比如在无效状态下调用某个操作），此时会回调OnErrorListener.onError()方法（需客户端提前注册listener）。一旦发生错误，MediaPlayer对象会进入Error状态，此时可以调用reset()方法把这个对象恢复到Idle状态。</p>\n\n<p>在不合法的状态下调用一些方法，如prepare()、prepareAsync()和setDataSource()等会抛出ILlegalStateException异常。</p>\n\n<p>3、Idle状态下，调用 setDataSource()方法会迁移到Initialized状态，非Idle状态下调用此方法会报 ILlegalStateException异常。注意，setDataSource()方法可能会抛出IOException异常。</p>\n\n<p>4、调用prepare()、prepareAsync()方法可以迁移到Prepared状态，该状态下才可以进行基本播放操作。</p>\n\n<p>异步的prepareAsync()方法需要通过OnPrepareListener.onPrepared()监听准备是否完成，Preparing是一个中间状态，如果在此状态下调用任何影响播放功能的方法，最终的运行结果都是未知的。</p>\n\n<p>在不合适的状态下调用prepare()和prepareAsync()方法会抛出ILlegalStateException异常。</p>\n\n<p>5、调用start()方法成功返回后，会迁移到Started状态，isPlaying()方法返回是否处于Started状态。迁移到Started状态时，可以通过OnBufferingUpdateListener.onBufferingUpdate()回调得知。</p>\n\n<p>Started状态下调用start()方法没有影响。</p>\n\n<p>6、调用pause()方法并返回时，会迁移到Paused状态。注意，Started与Paused状态的转换在内部的播放引擎中是异步的，所以isPlaying()可能会延时更新，如果是播放网络流媒体，这个延时可能会有几秒。</p>\n\n<p>Paused状态下调用pause()方法没有影响。</p>\n\n<p>7、除了Idle、Initialized状态，其它状态下都可以调用stop()迁移到Stopped状态，Stopped状态下调用stop()方法没有影响。</p>\n\n<p>8、seekTo()方法可以调整播放位置，seekTo()方法是异步的，尤其是播放网络流媒体时延时很明显。实际定位完成后，通过OnSeekComplete.onSeekComplete()通知。</p>\n\n<p>&ldquo;活动状态&rdquo;(Prepared、Started、Paused、PlaybackCompleted状态)下都可以调用seekTo()方法。</p>\n\n<p>9、迁移到PlaybackCompleted状态后，如果通过setLooping()方法开启了循环模式，会重新进入到Started状态，并且不会回调OnCompletion.onCompletion()方法、如果没有开启循环，就会回调这个方法。</p>\n\n<p>PlaybackCompleted状态下调用start()方法会迁移到Started状态。</p>\n\n<p>各方法的调用状态<br />\n除了下面几个方法调用时需要特别注意状态的判断，其余常用方法，基本所有状态都是OK的，或者即便状态不对也不会报错。如果对某个方法调用有疑问，查阅API文档，下面只列出一些常用的、需要注意状态的方法。</p>\n\n<p>下面这几个方法需要注意下：</p>\n\n<p>1、setDataSource()&nbsp;<br />\n有效状态：Idle&nbsp;<br />\n调用结果：调用成功，会迁移到Initialized状态&nbsp;<br />\n无效状态：报IllegalStateException异常</p>\n\n<p>2、prepare()、prepareAsync()&nbsp;<br />\n有效状态：Initialized/Stopped&nbsp;<br />\n调用结果：调用成功，会迁移到Prepared/Preparing状态&nbsp;<br />\n无效状态：报IllegalStateException异常</p>\n\n<p>3、pause()&nbsp;<br />\n有效状态：Started/Paused&nbsp;<br />\n调用结果：调用成功，会迁移到Paused状态&nbsp;<br />\n无效状态：player进入Error状态</p>\n\n<p>4、start()&nbsp;<br />\n有效状态：Prepared/Started/Paused/PlaybackCompleted&nbsp;<br />\n调用结果：调用成功，会迁移到Started状态&nbsp;<br />\n无效状态：player进入Error状态</p>\n\n<p>5、stop()&nbsp;<br />\n有效状态：Prepared/Started/Stopped/Paused/PlaybackCompleted&nbsp;<br />\n调用结果：调用成功，会迁移到Stopped状态&nbsp;<br />\n无效状态：player进入Error状态</p>\n\n<p>6、seekTo()&nbsp;<br />\n有效状态：Prepared/Started/Paused/PlaybackCompleted&nbsp;<br />\n调用结果：调用成功，不会改变player的状态&nbsp;<br />\n无效状态：player进入Error状态</p>\n\n<p>使用demo<br />\n使用之前先整理一下大概要用到播放操作的方法，每个方法的有效状态是怎样。</p>\n\n<p>大概要用到setDataSource()、prepare()、start()、pause()、seekTo()这5个方法，stop()方法一般不用，不播放的时候最好调release()释放资源。其中setDataSource()和prepare()基本就是初始化的时候连续调用，不太需要注意状态，所以剩下需要注意的也就start()、pause()和seekTo()这3个方法。</p>\n\n<p>排除stop()方法和Stopped状态后，从&ldquo;不可操作&rdquo;到&ldquo;可操作&rdquo;的分界点就在Prepared状态，所以我们可以使用一个变量hasPrepared来标记是否可操作，start()和seekTo()方法在&ldquo;可操作&rdquo;状态下都是可以正常调用的。</p>\n\n<p>剩下的就是pause()方法，只能在Started和Paused状态下调用，可以使用一个变量canPause来标记是否可以调用pause()方法。实际上，Prepared和PlaybackCompleted状态在程序中也基本是个瞬时状态，基本不会停留。一旦Prepared，程序就会调用start()方法进行播放；一旦PlaybackCompleted，就会进行下一个曲目的初始化、准备、播放。</p>\n\n<p>那么下面就看一下使用方法吧：</p>\n\n<p>public class MyPlayer implements MediaPlayer.OnPreparedListener, MediaPlayer.OnErrorListener, MediaPlayer.OnCompletionListener {<br />\n&nbsp; &nbsp; private MediaPlayer mPlayer;<br />\n&nbsp; &nbsp; private boolean hasPrepared;</p>\n\n<p>&nbsp; &nbsp; private void initIfNecessary() {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; if (null == mPlayer) {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mPlayer = new MediaPlayer();<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mPlayer.setOnErrorListener(this);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mPlayer.setOnCompletionListener(this);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mPlayer.setOnPreparedListener(this);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; }<br />\n&nbsp; &nbsp; }</p>\n\n<p>&nbsp; &nbsp; public void play(Context context, Uri dataSource) {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; hasPrepared = false; // 开始播放前讲Flag置为不可操作<br />\n&nbsp; &nbsp; &nbsp; &nbsp; initIfNecessary(); // 如果是第一次播放/player已经释放了，就会重新创建、初始化<br />\n&nbsp; &nbsp; &nbsp; &nbsp; try {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mPlayer.reset();<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mPlayer.setDataSource(context, dataSource); // 设置曲目资源<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mPlayer.prepareAsync(); // 异步的准备方法<br />\n&nbsp; &nbsp; &nbsp; &nbsp; } catch (IOException e) {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.printStackTrace();<br />\n&nbsp; &nbsp; &nbsp; &nbsp; }<br />\n&nbsp; &nbsp; }</p>\n\n<p>&nbsp; &nbsp; public void start() {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; // release()会释放player、将player置空，所以这里需要判断一下<br />\n&nbsp; &nbsp; &nbsp; &nbsp; if (null != mPlayer &amp;&amp; hasPrepared) {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mPlayer.start();<br />\n&nbsp; &nbsp; &nbsp; &nbsp; }<br />\n&nbsp; &nbsp; }</p>\n\n<p>&nbsp; &nbsp; public void pause() {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; if (null != mPlayer &amp;&amp; hasPrepared) {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mPlayer.pause();<br />\n&nbsp; &nbsp; &nbsp; &nbsp; }<br />\n&nbsp; &nbsp; }</p>\n\n<p>&nbsp; &nbsp; public void seekTo(int position) {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; if (null != mPlayer &amp;&amp; hasPrepared) {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mPlayer.seekTo(position);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; }<br />\n&nbsp; &nbsp; }</p>\n\n<p>&nbsp; &nbsp; // 对于播放视频来说，通过设置SurfaceHolder来设置显示Surface。这个方法不需要判断状态、也不会改变player状态<br />\n&nbsp; &nbsp; public void setDisplay(SurfaceHolder holder) {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; if (null != mPlayer) {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mPlayer.setDisplay(holder);<br />\n&nbsp; &nbsp; &nbsp; &nbsp; }<br />\n&nbsp; &nbsp; }<br />\n&nbsp; &nbsp; public void release() {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; hasPrepared = false;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; mPlayer.stop();<br />\n&nbsp; &nbsp; &nbsp; &nbsp; mPlayer.release();<br />\n&nbsp; &nbsp; &nbsp; &nbsp; mPlayer = null;<br />\n&nbsp; &nbsp; }</p>\n\n<p>&nbsp; &nbsp; @Override<br />\n&nbsp; &nbsp; public void onPrepared(MediaPlayer mp) {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; hasPrepared = true; // 准备完成后回调到这里<br />\n&nbsp; &nbsp; &nbsp; &nbsp; start();<br />\n&nbsp; &nbsp; }</p>\n\n<p>&nbsp; &nbsp; @Override<br />\n&nbsp; &nbsp; public void onCompletion(MediaPlayer mp) {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; hasPrepared = false;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; // 通知调用处，调用play()方法进行下一个曲目的播放<br />\n&nbsp; &nbsp; }</p>\n\n<p>&nbsp; &nbsp; @Override<br />\n&nbsp; &nbsp; public boolean onError(MediaPlayer mp, int what, int extra) {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; hasPrepared = false;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; return false;<br />\n&nbsp; &nbsp; }<br />\n}</p>\n', '0', '0', null, null, null, '1588053326211', '0', '1', null);
INSERT INTO `boke_boke` VALUES ('43ccb331c4804a4da24136ba6ee90472', 'PLSQL 下载、安装、配置驱动连接 详解', null, 'PLSQL 下载、安装、配置驱动连接 详解', 'BOKE202004284770', 'a8d54e799fa04d4f9f5f8d795638d2bd', '1588053395555', '0', '0', '<p>简介：</p>\n\n<p>PL/SQL Developer是一个集成开发环境，专门开发面向Oracle数据库的应用。PL/SQL也是一种程序语言，叫做过程化SQL语言（Procedural Language/SQL）。PL/SQL是Oracle数据库对SQL语句的扩展。在普通SQL语句的使用上增加了编程语言的特点，所以PL/SQL把数据操作和查询语句组织在PL/SQL代码的过程性单元中，通过逻辑判断、循环等操作实现复杂的功能或者计算。PL/SQL 只有 Oracle 数据库有。 MySQL 目前不支持 PL/SQL 的，但支持Navicat Premium。</p>\n\n<p>&nbsp;</p>\n\n<p>PLSQL下载</p>\n\n<p>PLSQL下载链接详见百度网盘&nbsp;链接：https://pan.baidu.com/s/1YV42rw6aeD8_qAhFqb9FXw&nbsp;</p>\n\n<p>提取码：n6il&nbsp;</p>\n\n<p>安装plsql需要oracle instance client&nbsp;</p>\n\n<p>oracle客户端组件下载链接</p>\n\n<p>链接：https://pan.baidu.com/s/1y23D-dVX_aHutESpP6JZ_g&nbsp;<br />\n提取码：n9sh&nbsp;<br />\n&nbsp;</p>\n\n<p>链接若失效，请转至我的csdn资源下载 &nbsp;&nbsp;&nbsp;&nbsp;&ldquo;plsql+oracle客户端&rdquo;</p>\n\n<p>&nbsp;</p>\n\n<p>安装配置</p>\n\n<p>1、解压plsql，并进行安装，安装过程中，选择默认即可</p>\n\n<p>2、安装完成后，点击桌面plsql图标，然后选择 &ldquo;取消&rdquo;进入配置界面</p>\n\n<p>3、解压下载好的oracle客户端软件instantclient-basic-nt-11.2.0.4.0.zip，记住解压目录，我解压目录为 &ldquo;D:\\程序\\plsql\\instantclient_11_2&rdquo;&nbsp;&nbsp;因为在下面配置plsql连接驱动的时候需要用到</p>\n\n<p>&nbsp;</p>\n\n<p>4、找到plsql的 tools 》preferences</p>\n\n<p>&nbsp;</p>\n\n<p>5、添加oracle客户端路径</p>\n\n<p>&nbsp;</p>\n\n<p>6、然后点，apply 》ok&nbsp;&nbsp;。然后重启plsql</p>\n\n<p>7、配置tnsnames文件</p>\n\n<p>在 客户端解压的目录 &ldquo;D:\\程序\\plsql\\instantclient_11_2&rdquo; 下创建NETWORK&nbsp;&nbsp;然后再在NETWORK下创建ADMIN目录</p>\n\n<p>然后再在 &lsquo;D:\\程序\\plsql\\instantclient_11_2\\NETWORK\\ADMIN&#39; 创建 tnsnames.ora文件，或者将数据库 端tnsnames文件拷贝过来</p>\n\n<p>我的tnsnames.ora 文件如下</p>\n\n<p>ORCL =<br />\n&nbsp;&nbsp;(DESCRIPTION =<br />\n&nbsp;&nbsp;&nbsp;&nbsp;(ADDRESS = (PROTOCOL = TCP)(HOST = 172.12.100.12)(PORT = 1521))<br />\n&nbsp;&nbsp;&nbsp;&nbsp;(CONNECT_DATA =<br />\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(SERVER = DEDICATED)<br />\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(SERVICE_NAME = orcl)<br />\n&nbsp;&nbsp;&nbsp;&nbsp;)<br />\n&nbsp;&nbsp;)</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>8、启动plsql ，即可成功连接</p>\n', '0', '0', null, null, null, '1588053395555', '0', '1', null);
INSERT INTO `boke_boke` VALUES ('6677f08861434e3b9517c5ec718c0f4c', 'mybatis-plus注解版实现多表联查（sql）', null, 'mybatis-plus注解版实现多表联查（sql）', 'BOKE202004287504', 'a8d54e799fa04d4f9f5f8d795638d2bd', '1588053495832', '0', '0', '<h1>mybatis注解版实现多表联查</h1>\n\n<h2>需求：</h2>\n\n<p>用户有角色，角色有权限，需要一次取用户信息包含角色信息及其对应权限</p>\n\n<h2>实体类:</h2>\n\n<p><img alt=\"\" src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" />&nbsp;用户</p>\n\n<p><img alt=\"\" src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" />&nbsp;角色</p>\n\n<p><img alt=\"\" src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" />&nbsp;权限</p>\n\n<p><img alt=\"\" src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" />&nbsp;用户角色关系</p>\n\n<p><img alt=\"\" src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" />&nbsp;角色权限关系</p>\n\n<p>注解是swagger2的，无需关注。另外有个&nbsp;@TableField(exist = false) 该注解标识这个字段非数据库字段</p>\n\n<h2>持久层处理：</h2>\n\n<pre>\n@Select(&quot;select * from  role where role_code in(select role_code from user_role where username = #{username})&quot;)\n    Set&lt;Role&gt; getUserRoles(String username);</pre>\n\n<pre>\n@Select(&quot;select * from permission where permission_code in (select permission_code from role_permission where role_code = #{roleCode})&quot;)\n    Set&lt;Permission&gt; getRolePermissions(String roleCode);</pre>\n\n<p>第一个sql为获取用户所拥有角色，第二个sql为获取角色所拥有权限</p>\n\n<h2>yml的配置上：</h2>\n\n<pre>\nmybatis-plus:\n  type-aliases-package: cn.zytao.taosir.common.model.user\n  configuration:\n    map-underscore-to-camel-case: true</pre>\n\n<p>映射实体类，开起对下划线转大写的处理</p>\n\n<h2>业务处理上：</h2>\n\n<p><a href=\"javascript:void(0);\" onclick=\"copyCnblogsCode(this)\"><img alt=\"复制代码\" src=\"https://common.cnblogs.com/images/copycode.gif\" /></a></p>\n\n<pre>\n    public User findByUsername(String username) {\n        User user = userMapper.findByUsername(username);\n        Set&lt;Role&gt; roles = userMapper.getUserRoles(username);\n        for (Role role : roles) {\n            role.setPermissions(roleMapper.getRolePermissions(role.getRoleCode()));\n        }\n        user.setRoles(roles);\n        return user;\n    }</pre>\n\n<p><a href=\"javascript:void(0);\" onclick=\"copyCnblogsCode(this)\"><img alt=\"复制代码\" src=\"https://common.cnblogs.com/images/copycode.gif\" /></a></p>\n\n<p>这样就可以很方便的解决多表的联查~因为本人比较懒，不想写配置版，也不喜欢在注解上用@Results来标示结果集</p>\n\n<p>仍在不断学习中，如有不妥还望指教~</p>\n\n<p>作者：<a href=\"https://www.cnblogs.com/it-taosir/\" target=\"_blank\">涛先森の日常</a>&nbsp;<br />\n出处：<a href=\"https://www.cnblogs.com/it-taosir/\" target=\"https://www.cnblogs.com/it-taosir/\">https://www.cnblogs.com/it-taosir/</a>&nbsp;<br />\n本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。</p>\n\n<p>分类:&nbsp;<a href=\"https://www.cnblogs.com/it-taosir/category/1332049.html\" target=\"_blank\">Java：强大的跨平台语言</a></p>\n\n<p><a href=\"javascript:void(0);\" onclick=\"DiggIt(9992246,cb_blogId,1);green_channel_success(this,\'谢谢推荐！\');\">好文要顶</a>&nbsp;<a href=\"javascript:void(0);\" onclick=\"follow(\'f0888d90-8c35-4b7a-0b3f-08d622c564f9\');\">关注我</a>&nbsp;<a href=\"javascript:void(0);\" onclick=\"AddToWz(cb_entryId);return false;\">收藏该文</a>&nbsp;<a href=\"javascript:void(0);\" onclick=\"ShareToTsina()\"><img alt=\"\" src=\"https://common.cnblogs.com/images/icon_weibo_24.png\" /></a>&nbsp;<a href=\"javascript:void(0);\" onclick=\"shareOnWechat()\"><img alt=\"\" src=\"https://common.cnblogs.com/images/wechat.png\" /></a></p>\n\n<p><a href=\"https://home.cnblogs.com/u/it-taosir/\" target=\"_blank\"><img alt=\"\" src=\"https://pic.cnblogs.com/face/1499500/20180927154911.png\" /></a></p>\n\n<p><a href=\"https://home.cnblogs.com/u/it-taosir/\">涛先森の日常</a><br />\n<a href=\"https://home.cnblogs.com/u/it-taosir/followees/\">关注 - 4</a><br />\n<a href=\"https://home.cnblogs.com/u/it-taosir/followers/\">粉丝 - 13</a></p>\n\n<p><a href=\"javascript:void(0);\" onclick=\"follow(\'f0888d90-8c35-4b7a-0b3f-08d622c564f9\');return false;\">+加关注</a></p>\n\n<p>0</p>\n\n<p>0</p>\n\n<p><a href=\"https://www.cnblogs.com/it-taosir/p/9986415.html\">&laquo;&nbsp;</a>上一篇：&nbsp;<a href=\"https://www.cnblogs.com/it-taosir/p/9986415.html\">mybatis-plus代码生成器</a>&nbsp;<br />\n<a href=\"https://www.cnblogs.com/it-taosir/p/9992546.html\">&raquo;&nbsp;</a>下一篇：&nbsp;<a href=\"https://www.cnblogs.com/it-taosir/p/9992546.html\">Git：Git的安装过程</a></p>\n\n<p>posted @&nbsp;2018-11-20 22:35&nbsp;&nbsp;<a href=\"https://www.cnblogs.com/it-taosir/\">涛先森の日常</a>&nbsp; 阅读(28236)&nbsp; 评论(2)&nbsp;&nbsp;<a href=\"https://i.cnblogs.com/EditPosts.aspx?postid=9992246\">编辑</a>&nbsp;&nbsp;<a href=\"javascript:void(0)\" onclick=\"AddToWz(9992246);return false;\">收藏</a></p>\n\n<p><a name=\"!comments\"></a></p>\n\n<p>&nbsp;</p>\n\n<p>评论列表</p>\n\n<p>&nbsp;&nbsp;</p>\n\n<p><a href=\"https://www.cnblogs.com/it-taosir/p/9992246.html#4148125\">#1楼</a>&nbsp;<a id=\"comment_anchor_4148125\" name=\"4148125\"></a>2018-12-25 17:58&nbsp;<a href=\"https://home.cnblogs.com/u/1301573/\" target=\"_blank\">维多</a></p>\n\n<p>请问连表查询 条件动态添加也能实现吗？</p>\n\n<p><a href=\"javascript:void(0);\" onclick=\"return voteComment(4148125, \'Digg\', this.parentElement, false);\">支持(0)&nbsp;</a><a href=\"javascript:void(0);\" onclick=\"return voteComment(4148125, \'Bury\', this.parentElement, false);\">反对(0)</a></p>\n\n<p>&nbsp;&nbsp;</p>\n\n<p><a href=\"https://www.cnblogs.com/it-taosir/p/9992246.html#4175266\">#2楼</a>&nbsp;<a id=\"comment_anchor_4175266\" name=\"4175266\"></a>[楼主]&nbsp;2019-02-01 14:18&nbsp;<a href=\"https://www.cnblogs.com/it-taosir/\" target=\"_blank\">涛先森の日常</a></p>\n\n<p><a href=\"https://www.cnblogs.com/it-taosir/p/9992246.html#4148125\" onclick=\"commentManager.renderComments(0,50,4148125);\">@</a>&nbsp;维多<br />\n可以的，现在才看到不好意思，之前一直在忙加班<br />\n可以用 if(执行条件,true操作,false操作) 这种形式<br />\n例如&nbsp;<br />\nselect * from user where 1=1 and if(#{name} is null,1=1,name like %#{name}%)<br />\n备注:1=1表示横成立</p>\n', '0', '0', null, null, null, '1588053495832', '0', '1', null);
INSERT INTO `boke_boke` VALUES ('7efa9d1b930e4b869f18f2b9a093c6ce', 'Android列表侧滑删除', null, 'Android列表侧滑删除', 'BOKE202004287656', 'a8d54e799fa04d4f9f5f8d795638d2bd', '1588053042068', '0', '0', '<p>创建一个Recyclerview列表item布局，自定义容器：<br />\nSlidingButtonView.java</p>\n\n<p>&nbsp;</p>\n\n<pre>\n<code>package com.huatec.myapplication.view;\n\nimport android.content.Context;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.MotionEvent;\nimport android.widget.HorizontalScrollView;\nimport android.widget.TextView;\n\nimport com.huatec.myapplication.R;\n\npublic class SlidingButtonView extends HorizontalScrollView {\n\n    private static final String TAG = &quot;SlidingButtonView&quot;;\n    private TextView lTextView_Delete;//删除按钮\n    private int lScrollWith;//横向滚动范围\n    private boolean first = false; //标记第一次进入获取删除按钮控件\n\n    public SlidingButtonView(Context context) {\n        this(context, null);\n    }\n\n    public SlidingButtonView(Context context, AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public SlidingButtonView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        this.setOverScrollMode(OVER_SCROLL_NEVER);\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        //第一次进入时获取删除控件\n        if (!first) {\n            lTextView_Delete = findViewById(R.id.tv_delete);\n            first = true;//修改标记\n        }\n    }\n\n    @Override\n    protected void onLayout(boolean changed, int l, int t, int r, int b) {\n        super.onLayout(changed, l, t, r, b);\n        //默认隐藏删除按钮\n        if (changed) {\n            this.scrollTo(0, 0);\n            //获取水平滚动条可以滚动的范围，也就是右侧删除按钮的宽度\n            lScrollWith = lTextView_Delete.getWidth();\n        }\n    }\n\n    //手势判断\n    @Override\n    public boolean onTouchEvent(MotionEvent ev) {\n        switch (ev.getAction()) {\n            case MotionEvent.ACTION_UP:\n            case MotionEvent.ACTION_CANCEL:\n                Log.d(TAG, &quot;onTouchEvent: &quot;);\n                changeScrollx();\n                return true;\n        }\n        return super.onTouchEvent(ev);\n    }\n\n    //根据滑动距离判断是否显示删除按钮\n    private void changeScrollx() {\n        //触摸滑动的距离大于删除按钮的一半时\n        if (getScrollX() &gt;= (lScrollWith / 2)) {\n            //显示删除按钮\n            this.smoothScrollTo(lScrollWith, 0);\n        } else {\n            //隐藏删除按钮\n            this.smoothScrollTo(0, 0);\n        }\n    }\n}\n</code></pre>\n\n<p>item:</p>\n\n<p>&nbsp;</p>\n\n<pre>\n<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;com.huatec.myapplication.view.SlidingButtonView\n    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;50dp&quot;\n    android:layout_marginBottom=&quot;1dp&quot;\n    android:background=&quot;@android:color/white&quot;&gt;\n\n    &lt;RelativeLayout\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;match_parent&quot;&gt;\n\n        &lt;!--删除按钮--&gt;\n        &lt;TextView\n            android:id=&quot;@+id/tv_delete&quot;\n            android:layout_width=&quot;80dp&quot;\n            android:layout_height=&quot;match_parent&quot;\n            android:layout_toRightOf=&quot;@+id/layout_content&quot;\n            android:background=&quot;@drawable/btn_click_red_bg&quot;\n            android:gravity=&quot;center&quot;\n            android:text=&quot;删除&quot;\n            android:textColor=&quot;@android:color/white&quot;/&gt;\n\n        &lt;!--行的布局文件--&gt;\n        &lt;RelativeLayout\n            android:id=&quot;@+id/layout_content&quot;\n            android:layout_width=&quot;match_parent&quot;\n            android:layout_height=&quot;match_parent&quot;\n            android:gravity=&quot;center_vertical&quot;&gt;\n\n            &lt;!--图标--&gt;\n            &lt;ImageView\n                android:id=&quot;@+id/img&quot;\n                android:layout_width=&quot;50dp&quot;\n                android:layout_height=&quot;50dp&quot;\n                android:background=&quot;@drawable/icon_1&quot;/&gt;\n\n            &lt;LinearLayout\n                android:layout_width=&quot;wrap_content&quot;\n                android:layout_height=&quot;match_parent&quot;\n                android:layout_toRightOf=&quot;@+id/img&quot;\n                android:gravity=&quot;center_vertical&quot;\n                android:orientation=&quot;vertical&quot;&gt;\n\n                &lt;TextView\n                    android:id=&quot;@+id/name&quot;\n                    android:layout_width=&quot;match_parent&quot;\n                    android:layout_height=&quot;wrap_content&quot;\n                    android:layout_marginLeft=&quot;20dp&quot;\n                    android:text=&quot;123&quot;\n                    android:textColor=&quot;@android:color/black&quot;\n                    android:textSize=&quot;15sp&quot;/&gt;\n\n                &lt;TextView\n                    android:id=&quot;@+id/info&quot;\n                    android:layout_width=&quot;match_parent&quot;\n                    android:layout_height=&quot;wrap_content&quot;\n                    android:layout_marginLeft=&quot;20dp&quot;\n                    android:layout_marginTop=&quot;2dp&quot;\n                    android:singleLine=&quot;true&quot;\n                    android:text=&quot;123&quot;\n                    android:textColor=&quot;@android:color/black&quot;\n                    android:textSize=&quot;10sp&quot;/&gt;\n\n            &lt;/LinearLayout&gt;\n\n        &lt;/RelativeLayout&gt;\n\n    &lt;/RelativeLayout&gt;\n\n&lt;/com.huatec.myapplication.view.SlidingButtonView&gt;\n</code></pre>\n\n<p>Adapter:</p>\n\n<p>&nbsp;</p>\n\n<pre>\n<code>package com.huatec.myapplication.adapter;\n\nimport android.content.Context;\nimport android.support.annotation.NonNull;\nimport android.support.v7.widget.RecyclerView;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.ImageView;\nimport android.widget.TextView;\n\nimport com.huatec.myapplication.R;\nimport com.huatec.myapplication.utils.Utils;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Adapter extends RecyclerView.Adapter&lt;Adapter.MyViewHolder&gt; {\n\n    //图标数组\n    private int[] icons = {\n            R.drawable.icon_1, R.drawable.icon_2, R.drawable.icon_3,\n            R.drawable.icon_4, R.drawable.icon_5, R.drawable.icon_6, R.drawable.icon_7,\n            R.drawable.icon_8, R.drawable.icon_9, R.drawable.icon_10, R.drawable.icon_11\n    };\n\n    //名字数组\n    private int[] names = {\n            R.string.name1, R.string.name2, R.string.name3, R.string.name4, R.string.name5,\n            R.string.name6, R.string.name7, R.string.name8, R.string.name9, R.string.name10,\n            R.string.name11\n    };\n\n    //信息数组\n    private int[] infos = {\n            R.string.info1, R.string.info2, R.string.info3, R.string.info4, R.string.info5,\n            R.string.info6, R.string.info7, R.string.info8, R.string.info9, R.string.info10,\n            R.string.info11\n    };\n\n    private Context lContent;//定义上下文\n\n    //集合\n    private List&lt;Integer&gt; listIcon = new ArrayList&lt;&gt;();\n    private List&lt;Integer&gt; listName = new ArrayList&lt;&gt;();\n    private List&lt;Integer&gt; listInfo = new ArrayList&lt;&gt;();\n\n    public Adapter(Context lContent) {\n        this.lContent = lContent;\n        //设置菜单行数与行内图标、名称、信息\n        for (int i = 0; i &lt; 11; i++) {\n            listIcon.add(icons[I]);\n            listName.add(names[I]);\n            listInfo.add(infos[I]);\n        }\n    }\n\n    @NonNull\n    @Override\n    public MyViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {\n        //获取列表中每行的布局文件\n        View view = LayoutInflater.from(lContent).inflate(R.layout.layout_item, parent, false);\n        return new MyViewHolder(view);\n    }\n\n    //设置列表中行所显示的内容\n    @Override\n    public void onBindViewHolder(@NonNull final MyViewHolder holder, int position) {\n        //设置图标\n        holder.img.setBackgroundResource(listIcon.get(position));\n        //设置名称\n        holder.name.setText(listName.get(position));\n        //设置信息\n        holder.info.setText(listInfo.get(position));\n        //设置内容宽度为屏幕的宽度\n        holder.layout_content.getLayoutParams().width = Utils.getScreenWidth(lContent);\n\n        //删除按钮的方法\n        holder.btn_delete.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                int n = holder.getLayoutPosition();//获取要删除行的位置\n                removeData(n);//删除列表中指定的行\n            }\n        });\n    }\n\n    //返回行的总数\n    @Override\n    public int getItemCount() {\n        return listIcon.size();\n    }\n\n    //删除列表行中信息的方法\n    public void removeData(int position){\n        listIcon.remove(position);//删除图标\n        listName.remove(position);//删除行中名字\n        listInfo.remove(position);//删除信息\n        notifyItemRemoved(position);//删除行\n    }\n\n\n    class MyViewHolder extends RecyclerView.ViewHolder {\n\n        public TextView btn_delete;\n        public TextView name, info;//名字与信息\n        public ImageView img;//图标\n        public ViewGroup layout_content;//图标与信息布局\n\n        //获取控件\n        public MyViewHolder(View itemView) {\n            super(itemView);\n            name = itemView.findViewById(R.id.name);\n            info = itemView.findViewById(R.id.info);\n            img = itemView.findViewById(R.id.img);\n            layout_content = itemView.findViewById(R.id.layout_content);\n            btn_delete = itemView.findViewById(R.id.tv_delete);\n        }\n    }\n}\n</code></pre>\n\n<p>效果图：</p>\n\n<p>&nbsp;</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/3876973-233373bae9836ed4.gif?imageMogr2/auto-orient/strip|imageView2/2/w/281/format/webp\" /></p>\n\n<p>2018-05-19 22_25_32.gif</p>\n\n<p>源码地址：<a href=\"https://github.com/280357392/SlidingButtonView\" target=\"_blank\">https://github.com/280357392/SlidingButtonView</a></p>\n\n<p><br />\n<br />\n作者：蒙伟<br />\n链接：https://www.jianshu.com/p/adb319e42ea6<br />\n来源：简书<br />\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n', '0', '0', null, null, null, '1588053042068', '0', '1', null);
INSERT INTO `boke_boke` VALUES ('8ffdacc440ef4602b407353ec9381736', 'Android Camera相机原理解析(源码)', null, 'Android Camera相机原理解析(源码)', 'BOKE202004283690', 'a8d54e799fa04d4f9f5f8d795638d2bd', '1588053186380', '0', '0', '<p>在应用软件开发中，图片数据，对于一个公司来说是十分重要的，例如：上传图片资料，修改用户头像等，而这其中就离不开相机和相册的使用。对于ios平台来说，直接调用系统相机或相册，就可搞定一切。然而对于Android平台来说，直接调用系统相机或相册，在适配和体验上问题比较多，具体原因，相比大家也知道，安卓品牌太多太杂，性能不一。鉴于此，在开发的过程中，遇到类似问题，建议自己实现相机或相册功能，以保证体验完整。本篇博文将会重点介绍Camera相机的实现。</p>\n\n<p>首先，推荐两个github项目，可以直接使用的相机和相册；另外，也推荐一个联系人选择器：</p>\n\n<p>相机：CameraDemo(自定义相机)</p>\n\n<p>相册：ImageSelector(仿微信图片选择相册)</p>\n\n<p>联系人：ContactSelector(联系人选择器)<br />\n&nbsp;</p>\n', '0', '0', null, null, null, '1588053186380', '0', '1', null);
INSERT INTO `boke_boke` VALUES ('b03efac36b614291afcb3762af0b516c', 'Android MVP 架构', '', 'Android MVP 架构', 'BOKE202004284060', 'a8d54e799fa04d4f9f5f8d795638d2bd', '1588045472169', '0', '0', '<p>本Demo使用 Okhttp3、Retrofit2、Rxjava2 ，使用AutoDispose解决RxJava内存泄漏<br />\nGithub：<br />\n<a href=\"https://github.com/RookieExaminer/MvpDemo\" target=\"_blank\">https://github.com/RookieExaminer/MvpDemo</a></p>\n\n<p>什么是MVP，为什么要用MVP？<br />\n网上介绍MVP的很多，百度一下你就知道，至于为什么要用MVP，当然是由于它的优势了：<br />\n1.代码简洁<br />\n此处的简洁是逻辑的简洁，而不是代码本身 举个栗子</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/3974484-06f987be684a6485.png?imageMogr2/auto-orient/strip|imageView2/2/w/136/format/webp\" /></p>\n\n<p>image.png</p>\n\n<p>比如购物车界面，有很多请求网络的地方：获取购物车商品列表、购物车商品的删除、购物车商品的购买等等， 这么多网络请求，如果都写在一个Activity，而且还有大量逻辑判断，那这个Activity的行数~ 看着就让人头痛， 即便写了注释，维护起来也是比较麻烦的<br />\n2.降低耦合，方便维护<br />\nMVP的使用，使Activity中的网络请求剥离出来 成为model、presenter，model只负责网络的请求、pesenter负责处理请求网络后的数据处理：加载中 成功 or 失败 取消加载；最后View进行界面的展示</p>\n\n<p>&nbsp;</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/3974484-c53536ec1906ee1e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1103/format/webp\" /></p>\n\n<p>image.png</p>\n\n<p>&nbsp;</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/3974484-24fa547b8e7b4d37.png?imageMogr2/auto-orient/strip|imageView2/2/w/659/format/webp\" /></p>\n\n<p>image.png</p>\n\n<p>Start 看图：</p>\n\n<p><img src=\"//upload-images.jianshu.io/upload_images/3974484-ce1b7e4aad9b8572.png?imageMogr2/auto-orient/strip|imageView2/2/w/1116/format/webp\" /></p>\n\n<p>image.png</p>\n\n<p>嗯哼？ 不是 Model、Presenter、View这三个 么，怎么又多出来个Contract，这又是什么鬼？<br />\n这就涉及到MVP的缺点了，正所谓，金无足赤，人无完人，MVP既然有优点当然也有它的缺点了<br />\nMVP在实现代码简洁的同时，额外增加了大量的接口、类，不方便进行管理，于是Contract就登场了。</p>\n\n<p>Contract 百度翻译 : 合同;契约;协议<br />\nContract 如其名，是一个契约，将Model、View、Presenter 进行约束管理，方便后期类的查找、维护。</p>\n\n<p>下面演示下登陆的MVP实现方式：<br />\n（示例代码由开发项目中剥离到Demo中，登陆接口使用的是玩安卓的登陆API：<a href=\"http://www.wanandroid.com/blog/show/2\" target=\"_blank\">http://www.wanandroid.com/blog/show/2</a>）</p>\n\n<p>&nbsp;</p>\n\n<pre>\n<code>首先，创建一个登陆的Contract：\n\npublic interface MainContract {\n    interface Model { }\n\n    interface View extends BaseView { }\n\n    interface Presenter { }\n}\n其次创建Presenter、Model、View 对应Contract中的接口；\npublic class MainPresenter implements  MainContract.Presenter{} \npublic class MainModel implements MainContract.Model{}\npublic class MainActivity  implements MainContract.View {}\n\n</code></pre>\n\n<p>完整的Contract：</p>\n\n<p>&nbsp;</p>\n\n<pre>\n<code>public interface MainContract {\n    interface Model {\n        Flowable&lt;BaseObjectBean&lt;LoginBean&gt;&gt; login(String username, String password);\n    }\n\n    interface View extends BaseView {\n        @Override\n        void showLoading();\n\n        @Override\n        void hideLoading();\n\n        @Override\n        void onError(Throwable throwable);\n\n        void onSuccess(BaseObjectBean&lt;LoginBean&gt; bean);\n    }\n\n    interface Presenter {\n        /**\n         * 登陆\n         *\n         * @param username\n         * @param password\n         */\n        void login(String username, String password);\n    }\n}\n</code></pre>\n\n<p>在MainContract 中<br />\nModel接口 创建对应的联网请求的方法，将Presenter提交的字段放到联网请求中，发送给服务器<br />\nView 接口 创建在界面上显示加载中、取消加载以及登陆成功、失败的方法<br />\nPresenter 接口 创建 登陆的方法，以及需要提交的字段 (username、password)</p>\n\n<p>MainModel的完整代码：</p>\n\n<p>&nbsp;</p>\n\n<pre>\n<code>public class MainModel  implements MainContract.Model {\n    @Override\n    public Flowable&lt;BaseObjectBean&lt;LoginBean&gt;&gt; login(String username, String password) {\n        return RetrofitClient.getInstance().getApi().login(username,password);\n    }\n}\n</code></pre>\n\n<p>Model类实现MainContract.Model 接口中的 login(String username, String password)方法，将username、password放在联网请求中，进行请求服务器。</p>\n\n<p>MainView 的完整代码：</p>\n\n<p>&nbsp;</p>\n\n<pre>\n<code>public class MainActivity extends BaseMvpActivity&lt;MainPresenter&gt; implements MainContract.View {\n\n    @BindView(R.id.et_username_login)\n    TextInputEditText etUsernameLogin;\n    @BindView(R.id.et_password_login)\n    TextInputEditText etPasswordLogin;\n\n    @Override\n    public int getLayoutId() {\n        return R.layout.activity_main;\n    }\n\n    @Override\n    public void initView() {\n        mPresenter = new MainPresenter();\n        mPresenter.attachView(this);\n    }\n\n    /**\n     * @return 帐号\n     */\n    private String getUsername() {\n        return etUsernameLogin.getText().toString().trim();\n    }\n\n    /**\n     * @return 密码\n     */\n    private String getPassword() {\n        return etPasswordLogin.getText().toString().trim();\n    }\n\n    @Override\n    public void onSuccess(BaseObjectBean bean) {\n\n        Toast.makeText(this, bean.getErrorMsg(), Toast.LENGTH_SHORT).show();\n\n    }\n\n    @Override\n    public void showLoading() {\n        ProgressDialog.getInstance().show(this);\n    }\n\n    @Override\n    public void hideLoading() {\n        ProgressDialog.getInstance().dismiss();\n    }\n\n    @Override\n    public void onError(Throwable throwable) {\n\n    }\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        // TODO: add setContentView(...) invocation\n        ButterKnife.bind(this);\n    }\n\n    @OnClick(R.id.btn_signin_login)\n    public void onViewClicked() {\n        if (getUsername().isEmpty() || getPassword().isEmpty()) {\n            Toast.makeText(this, &quot;帐号密码不能为空&quot;, Toast.LENGTH_SHORT).show();\n            return;\n        }\n        mPresenter.login(getUsername(), getPassword());\n    }\n}\n</code></pre>\n\n<p>MainActivity 中实现 MainContract.View中的方法 ，在实现的方法中，进行进度条加载、和登陆成功or失败的UI的展示：</p>\n\n<p>&nbsp;</p>\n\n<pre>\n<code>        @Override\n        void showLoading();\n\n        @Override\n        void hideLoading();\n\n        @Override\n        void onError(Throwable throwable);\n\n        void onSuccess(BaseObjectBean&lt;LoginBean&gt; bean);\n</code></pre>\n\n<p>MainPresenter 的完整代码：</p>\n\n<p>&nbsp;</p>\n\n<pre>\n<code>public class MainPresenter extends BasePresenter&lt;MainContract.View&gt; implements MainContract.Presenter {\n\n    private MainContract.Model model;\n\n    public MainPresenter() {\n        model = new MainModel();\n    }\n\n    @Override\n    public void login(String username, String password) {\n        if (!isViewAttached()) {\n            return;\n        }\n        mView.showLoading();\n        model.login(username, password)\n                .compose(RxScheduler.&lt;BaseObjectBean&lt;LoginBean&gt;&gt;Flo_io_main())\n                .as(mView.&lt;BaseObjectBean&lt;LoginBean&gt;&gt;bindAutoDispose())\n                .subscribe(new Consumer&lt;BaseObjectBean&lt;LoginBean&gt;&gt;() {\n                    @Override\n                    public void accept(BaseObjectBean&lt;LoginBean&gt; bean) throws Exception {\n                        mView.onSuccess(bean);\n                        mView.hideLoading();\n                    }\n                }, new Consumer&lt;Throwable&gt;() {\n                    @Override\n                    public void accept(Throwable throwable) throws Exception {\n                        mView.onError(throwable);\n                        mView.hideLoading();\n                    }\n                });\n    }\n}\n</code></pre>\n\n<p>MainPresenter 实现MainContract.Presenter 接口中的 login(String username, String password) 方法</p>\n\n<p>实例化Model，在MainPresenter login(String username, String password)方法中，调用model的网络请求，将username、password放在model的login()方法中，进行请求服务器。<br />\n请求服务器前 使用MainContract.View中的 mView.showLoading()方法，进行显示加载中；在成功失败的回调中，使用对应的方法，以及取消加载。</p>\n\n<p>其中BasePresenter、BaseView 是对Presenter以及View进行的封装</p>\n\n<p>BaseView类：</p>\n\n<p>&nbsp;</p>\n\n<pre>\n<code>public interface BaseView {\n\n    /**\n     * 显示加载中\n     */\n    void showLoading();\n\n    /**\n     * 隐藏加载\n     */\n    void hideLoading();\n\n    /**\n     * 数据获取失败\n     * @param throwable\n     */\n    void onError(Throwable throwable);\n\n    /**\n     * 绑定Android生命周期 防止RxJava内存泄漏\n     *\n     * @param &lt;T&gt;\n     * @return\n     */\n    &lt;T&gt; AutoDisposeConverter&lt;T&gt; bindAutoDispose();\n\n}\n</code></pre>\n\n<p>至于为什么不把onSuccess()方法也封装，是因为请求网络，服务器返回的值是不一样的，在Contract &gt; View接口中根据bean类设置onSuccess()</p>\n\n<p>BasePresenter类：</p>\n\n<p>&nbsp;</p>\n\n<pre>\n<code>public class BasePresenter&lt;V extends BaseView&gt; {\n    protected V mView;\n\n\n    /**\n     * 绑定view，一般在初始化中调用该方法\n     *\n     * @param view view\n     */\n    public void attachView(V view) {\n        this.mView = view;\n    }\n\n    /**\n     * 解除绑定view，一般在onDestroy中调用\n     */\n\n    public void detachView() {\n        this.mView = null;\n    }\n\n    /**\n     * View是否绑定\n     *\n     * @return\n     */\n    public boolean isViewAttached() {\n        return mView != null;\n    }\n\n\n}\n</code></pre>\n\n<p>时间有限，暂时就先这样，具体可下载Demo查看 &darr;</p>\n\n<p>本Demo： <a href=\"https://github.com/RookieExaminer/MvpDemo\" target=\"_blank\">https://github.com/RookieExaminer/MvpDemo</a><br />\nMVP快速生成类的插件： <a href=\"https://github.com/githubwing/MVPHelper\" target=\"_blank\">https://github.com/githubwing/MVPHelper</a></p>\n\n<p>参考：<br />\nAndroid MVP架构搭建：<br />\n<a href=\"http://www.jcodecraeer.com/a/anzhuokaifa/2017/1020/8625.html?1508484926\" target=\"_blank\">http://www.jcodecraeer.com/a/anzhuokaifa/2017/1020/8625.html?1508484926</a><br />\nAndroid架构中添加AutoDispose解决RxJava内存泄漏：<br />\n<a href=\"https://www.jianshu.com/p/8490d9383ba5\" target=\"_blank\">https://www.jianshu.com/p/8490d9383ba5</a></p>\n\n<p><br />\n<br />\n作者：菜鸟考官<br />\n链接：https://www.jianshu.com/p/ae0b21d3238a<br />\n来源：简书<br />\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n', '0', '0', null, null, null, '1589250323272', '0', '1', null);
INSERT INTO `boke_boke` VALUES ('c503f4473b96479380afb2884e0f6201', '十分钟理解Gradle', null, '十分钟理解Gradle', 'BOKE202004281107', 'a8d54e799fa04d4f9f5f8d795638d2bd', '1588053090862', '0', '0', '<p><strong>一、什么是Gradle</strong></p>\n\n<p>&nbsp;</p>\n\n<p>简单的说，Gradle是一个构建工具，它是用来帮助我们构建app的，构建包括编译、打包等过程。我们可以为Gradle指定构建规则，然后它就会根据我们的&ldquo;命令&rdquo;自动为我们构建app。Android Studio中默认就使用Gradle来完成应用的构建。有些同学可能会有疑问：&rdquo;我用AS不记得给Gradle指定过什么构建规则呀，最后不还是能搞出来个apk。&ldquo; 实际上，app的构建过程是大同小异的，有一些过程是&rdquo;通用&ldquo;的，也就是每个app的构建都要经历一些公共步骤。因此，在我们在创建工程时，Android Studio自动帮我们生成了一些通用构建规则，很多时候我们甚至完全不用修改这些规则就能完成我们app的构建。</p>\n\n<p>有些时候，我们会有一些个性化的构建需求，比如我们引入了第三方库，或者我们想要在通用构建过程中做一些其他的事情，这时我们就要自己在系统默认构建规则上做一些修改。这时候我们就要自己向Gradle&rdquo;下命令&ldquo;了，这时候我们就需要用Gradle能听懂的话了，也就是Groovy。Groovy是一种基于JVM的动态语言，关于它的具体介绍，感兴趣的同学可以文末参考&rdquo;延伸阅读&ldquo;部分给出的链接。</p>\n\n<p>&nbsp;</p>\n\n<p>我们在开头处提到&ldquo;Gradle是一种构建工具&rdquo;。实际上，当我们想要更灵活的构建过程时，Gradle就成为了一个编程框架&mdash;&mdash;我们可以通过编程让构建过程按我们的意愿进行。也就是说，当我们把Gradle作为构建工具使用时，我们只需要掌握它的配置脚本的基本写法就OK了；而当我们需要对构建流程进行高度定制时，就务必要掌握Groovy等相关知识了。限于篇幅，本文只从构建工具使用者的角度来介绍Gradle的一些最佳实践，在文末&ldquo;延伸阅读&rdquo;部分给出了几篇高质量的深入介绍Gradle的文章，其中包含了Groovy等知识的介绍。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>二、Gradle的基本组分</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>1. Project与Task</strong></p>\n\n<p>在Gradle中，每一个待构建的工程是一个Project，构建一个Project需要执行一系列Task，比如编译、打包这些构建过程的子过程都对应着一个Task。具体来说，一个apk文件的构建包含以下Task：Java源码编译、资源文件编译、Lint检查、打包以生成最终的apk文件等等。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2. 插件</strong></p>\n\n<p>插件的核心工作有两个：一是定义Task；而是执行Task。也就是说，我们想让Gradle能正常工作，完成整个构建流程中的一系列Task的执行，必须导入合适的插件，这些插件中定义了构建Project中的一系列Task，并且负责执行相应的Task。</p>\n\n<p>在新建工程的app模块的build.gradle文件的第一行，往往都是如下这句：</p>\n\n<pre>\napply plugin: &#39;com.android.application&#39;</pre>\n\n<p>这句话的意思就是应用&ldquo;com.android.application&ldquo;这个插件来构建app模块，app模块就是Gradle中的一个Project。也就是说，这个插件负责定义并执行Java源码编译、资源文件编译、打包等一系列Task。实际上&quot;com.android.application&quot;整个插件中定义了如下4个顶级任务：</p>\n\n<ul>\n	<li>\n	<p>assemble: 构建项目的输出（apk）</p>\n	</li>\n	<li>\n	<p>check: 进行校验工作</p>\n	</li>\n	<li>\n	<p>build: 执行assemble任务与check任务</p>\n	</li>\n	<li>\n	<p>clean: 清除项目的输出</p>\n	</li>\n</ul>\n\n<p>当我们执行一个任务时，会自动执行它所依赖的任务。比如，执行assemble任务会执行assembleDebug任务和assembleRelease任务，这是因为一个Android项目至少要有debug和release这两个版本的输出。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>3. Gradle配置文件</strong></p>\n\n<p>我们在Android Studio中新建一个工程，可以得到如下的工程结构图：</p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"http://mmbiz.qpic.cn/mmbiz/MSRNlm12CCjKRr81icVrMDF8GbOzhVQoVnr9HBgck9SZ5s3Ao6kza1o1MD0V6vh70SoPPoKiacddlrToAfPeq0EA/0?wx_fmt=png\" /></p>\n\n<p>上面我们说过，Android Studio中的一个Module即为Gradle中的一个Project。上图的app目录下，存在一个build.gradle文件，代表了app Module的构建脚本，它定义了应用于本模块的构建规则。我们可以看到，工程根目录下也存在一个build.gradle文件，它代表了整个工程的构建，其中定义了适用于这个工程中所有模块的构建规则。</p>\n\n<p>接下来我们介绍一下上图中其他几个Gradle配置文件：</p>\n\n<ul>\n	<li>\n	<p><strong>gradle.properties</strong>:&nbsp;从它的名字可以看出，这个文件中定义了一系列&ldquo;属性&rdquo;。实际上，这个文件中定义了一系列供build.gradle使用的常量，比如keystore的存储路径、keyalias等等。</p>\n	</li>\n	<li>\n	<p><strong>gradlew与gradlew.bat</strong>: gradlew为Linux下的shell脚本，gradlew.bat是Windows下的批处理文件。gradlew是gradle wrapper的缩写，也就是说它对gradle的命令进行了包装，比如我们进入到指定Module目录并执行&ldquo;gradlew.bat assemble&rdquo;即可完成对当前Module的构建（Windows系统下）。</p>\n	</li>\n	<li>\n	<p><strong>local.properties</strong>: 从名字就可以看出来，这个文件中定义了一些本地属性，比如SDK的路径。</p>\n	</li>\n	<li>\n	<p><strong>settings.gradle</strong>: 假如我们的项目包含了不只一个Module时，我们想要一次性构建所有Module以完成整个项目的构建，这时我们需要用到这个文件。比如我们的项目包含了ModuleA和ModuleB这两个模块，则这个文件中会包含这样的语句：include &#39;:ModuleA&#39;, &#39;:ModuleB&#39;。</p>\n	</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong><strong><strong><strong>4. 构建脚本</strong></strong></strong></strong></p>\n\n<p>首先我们来看一下工程目录下的build.gradle，它指定了真个整个项目的构建规则，它的内容如下：</p>\n\n<p>&nbsp;</p>\n\n<pre>\nbuildscript {\n    repositories {\n        jcenter() //构建脚本中所依赖的库都在jcenter仓库下载\n    }\n    dependencies {\n        //指定了gradle插件的版本\n        classpath &#39;com.android.tools.build:gradle:1.5.0&#39;\n &nbsp; &nbsp;}\n}\n\nallprojects {\n    repositories {\n        //当前项目所有模块所依赖的库都在jcenter仓库下载\n        jcenter()\n    }\n}</pre>\n\n<p>&nbsp;</p>\n\n<p>我们再来简单介绍下app模块的build.gradle的内容：</p>\n\n<p>&nbsp;</p>\n\n<pre>\n//加载用于构建Android项目的插件\napply plugin: &#39;com.android.application&#39;\n\nandroid { //构建Android项目使用的配置\n    compileSdkVersion 23 //指定编译项目时使用的SDK版本\n &nbsp; &nbsp;buildToolsVersion &quot;23.0.1&quot; //指定构建工具的版本\n\n &nbsp; &nbsp;defaultConfig {\n        applicationId &quot;com.absfree.debugframwork&quot; //包名\n &nbsp; &nbsp; &nbsp; &nbsp;minSdkVersion 15 &nbsp;//指定支持的最小SDK版本\n &nbsp; &nbsp; &nbsp; &nbsp;targetSdkVersion 23 //针对的目标SDK版本\n &nbsp; &nbsp; &nbsp; &nbsp;versionCode 1 \n &nbsp; &nbsp; &nbsp; &nbsp;versionName &quot;1.0&quot;\n &nbsp; &nbsp;}\n    buildTypes { //针对不同的构建版本进行一些设置\n        release { //对release版本进行的设置\n            minifyEnabled false //是否开启混淆\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39; &nbsp;//指定混淆文件的位置\n &nbsp; &nbsp; &nbsp; &nbsp;}\n    }\n}\n\ndependencies { //指定当前模块的依赖\n    compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])\n    testCompile &#39;junit:junit:4.12&#39;\n &nbsp; &nbsp;compile &#39;com.android.support:appcompat-v7:23.1.1&#39;\n &nbsp; &nbsp;compile &#39;com.android.support:design:23.1.1&#39;\n}</pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>三、常见配置</strong></p>\n\n<p>整个工程的build.gradle通常不需我们改动，这里我们介绍下一些对模块目录下build.gradle文件的常见配置。</p>\n\n<p><strong>&nbsp;</strong></p>\n\n<p><strong>1. 依赖第三方库</strong></p>\n\n<p>当我们的项目中用到了了一些第三方库时，我们就需要进行一些配置，以保证能正确导入相关依赖。设置方法很简单，比如我们在app模块中中用到了Fresco，只需要在build.gradle文件中的dependencies块添加如下语句：</p>\n\n<p>&nbsp;</p>\n\n<pre>\ndependencies {\n    ...\n    compile &#39;com.facebook.fresco:fresco:0.11.0&#39;\n}</pre>\n\n<p>&nbsp;</p>\n\n<p>这样一来，Gradle会自动从jcenter仓库下载我们所需的第三方库并导入到项目中。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>2. 导入本地jar包</strong></p>\n\n<p>在使用第三方库时，除了像上面那样从jcenter仓库下载，我们还可以导入本地的jar包。配置方法也很简单，只需要先把jar文件添加到app\\libs目录下，然后在相应jar文件上单击右键，选择&ldquo;Ad As Library&rdquo;。然后在build.gradle的dependencies块下添加如下语句：</p>\n\n<p>&nbsp;</p>\n\n<pre>\ncompile files(&#39;libs/xxx.jar&#39;)</pre>\n\n<p>实际上我们可以看到，系统为我们创建的build.gradle中就已经包含了如下语句：</p>\n\n<pre>\ncompile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])</pre>\n\n<p>&nbsp;</p>\n\n<p>这句话的意思是，将libs目录下的所有jar包都导入。所以实际上我们只需要把jar包添加到libs目录下并&ldquo;Ad As Library&quot;即可。</p>\n\n<p><br />\n&nbsp;</p>\n\n<p><strong>3. 依赖其它模块</strong></p>\n\n<p>假设我们的项目包含了多个模块，并且app模块依赖other模块，那么我们只需app\\build.gradle的denpendencies块下添加如下语句：</p>\n\n<p>&nbsp;</p>\n\n<pre>\ncompile project(&#39;:other&#39;)</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>4. 构建输出为aar文件</strong></p>\n\n<p>通常我们构建的输出目标都是apk文件，但如果我们的当前项目时Android Library，我们的目标输出就是aar文件。要想达到这个目的也很容易，只需要把build.gradle的第一句改为如下：</p>\n\n<pre>\napply plugin:&#39;com.android.library&#39;</pre>\n\n<p>这话表示我们使用的插件不再是构建Android应用的插件，而是构建Android Library的插件，这个插件定义并执行用于构建Android Library的一系列Task。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>5. 自动移除不再使用的资源</strong></p>\n\n<p>只需进行如下配置：</p>\n\n<p>&nbsp;</p>\n\n<pre>\nandroid {\n &nbsp; &nbsp;...\n &nbsp; &nbsp;}\n &nbsp; &nbsp;buildTypes {\n &nbsp; &nbsp; &nbsp; &nbsp;release {\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;shrinkResources true\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...\n &nbsp; &nbsp; &nbsp; &nbsp;}\n &nbsp; &nbsp;}\n}</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>6. 忽略Lint错误</strong></p>\n\n<p>在我们构建Android项目的过程中，有时候会由于Lint错误而终止。当这些错误来自第三方库中时，我们往往想要忽略这些错误从而继续构建进程。这时候，我们可以只需进行如下配置：</p>\n\n<pre>\nandroid {\n    ...\n    lintOptions {\n        abortOnError false\n &nbsp; &nbsp;}\n}</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>7. 集成签名配置</strong></p>\n\n<p>在构建release版本的Android项目时，每次都手动导入签名文件，键入密码、keyalias等信息十分麻烦。通过将签名配置集成到构建脚本中，我们就不必每次构建发行版本时都手动设置了。具体配置如下：</p>\n\n<p>&nbsp;</p>\n\n<pre>\nsigningConfigs {\n    myConfig { //将&quot;xx&quot;替换为自己的签名文件信息\n        storeFile file(&quot;xx.jks&quot;)\n        storePassword &quot;xx&quot;\n &nbsp; &nbsp; &nbsp; &nbsp;keyAlias &quot;xx&quot;\n &nbsp; &nbsp; &nbsp; &nbsp;keyPassword &quot;xx&quot;\n &nbsp; &nbsp;}\n}\nandroid {\n    buildTypes {\n        release {\n            signingConfig &nbsp;signingConfigs.myConfig //在release块中加入这行\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...\n &nbsp; &nbsp; &nbsp; &nbsp;}\n    }\n    ...\n}</pre>\n\n<p>&nbsp;</p>\n\n<p>真实开发中，我们不应该把密码等信息直接写到build.gradle中，更好的做法是放在gradle.properties中设置：</p>\n\n<pre>\nRELEASE_STOREFILE=xxx.jks \nRELEASE_STORE_PASSWORD = xxx\nRELEASE_KEY_ALIAS=xxx\nRELEASE_KEY_PASSWORD=xxx</pre>\n\n<p>&nbsp;</p>\n\n<p>然后在build.gradle中直接引用即可：</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<pre>\nsigningConfigs {\n    myConfig { \n &nbsp; &nbsp; &nbsp; &nbsp;storeFilefile(RELEASE_STOREFILE)\n        storePassword RELEASE_STORE_PASSWORD\n        keyAlias RELEASE_KEY_ALIAS\n        keyPassword RELEASE_KEY_PASSWORD \n &nbsp; &nbsp;}\n}</pre>\n\n<p>&nbsp;</p>\n\n<p>关于Gradle的其他配置方法大家可以参考&ldquo;延伸阅读&rdquo;部分的&ldquo;Gradle最佳实践&rdquo;。</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>四、延伸阅读</p>\n\n<p>1. 深入理解Android之Gradle:http://blog.csdn.net/Innost/article/details/48228651</p>\n\n<p><strong>&nbsp; &nbsp;邓凡平老师的一篇博文，从原理到使用非常深入细致地介绍了Gradle。而且重点介绍了怎样把Gradle当做一个编程框架来使用，介绍了Groovy语法基础、Gradle常用API，想要高度定制项目构建过程的小伙伴们一定不要错过这篇文章哦：）</strong></p>\n\n<p>&nbsp;</p>\n\n<p>2. Gradle构建最佳实践: http://www.figotan.org/2016/04/01/gradle-on-android-best-practise/</p>\n\n<p><strong>这篇文章主要从使用者的角度介绍了Gradle在使用过程中的最佳实践，同样非常精彩。</strong></p>\n', '0', '0', null, null, null, '1588053090862', '0', '1', null);
INSERT INTO `boke_boke` VALUES ('df268f5212b941d2ba7373353ee8cd6d', '8 种方案解决重复提交问题！你选择哪一种呀？', 'b4b12fb9ae6844fb865cf3344c1cc034', '8 种方案解决重复提交问题！你选择哪一种呀？', 'BOKE202005134197', 'a8d54e799fa04d4f9f5f8d795638d2bd', '1589353496259', '0', '0', '<h1>1.什么是幂等</h1>\n\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;mid=2247487551&amp;idx=1&amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;scene=21#wechat_redirect\"><img alt=\"\" src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9KZExrRUk5c1pmZU9WWjFGR0ZOYlRoU1VIQ2NaS3FsQzlDUXRuMUFwa1QzYUZrME1ac0o2TDEzSGhqcFRUaWI0d0tiYTJ2TGlhWGR5aFRFb01BV3NSUnRBLzY0MA?x-oss-process=image/format,png\" /></a></p>\n\n<p>在我们编程中常见幂等</p>\n\n<ul>\n	<li>\n	<p>select查询天然幂等</p>\n	</li>\n	<li>\n	<p>delete删除也是幂等,删除同一个多次效果一样</p>\n	</li>\n	<li>\n	<p>update直接更新某个值的,幂等</p>\n	</li>\n	<li>\n	<p>update更新累加操作的,非幂等</p>\n	</li>\n	<li>\n	<p>insert非幂等操作,每次新增一条</p>\n	</li>\n</ul>\n\n<h1><a name=\"t1\"></a><a name=\"t1\"></a>2.产生原因</h1>\n\n<p>由于重复点击或者网络重发 eg:</p>\n\n<ul>\n	<li>\n	<p>点击提交按钮两次;</p>\n	</li>\n	<li>\n	<p>点击刷新按钮;</p>\n	</li>\n	<li>\n	<p>使用浏览器后退按钮重复之前的操作，导致重复提交表单;</p>\n	</li>\n	<li>\n	<p>使用浏览器历史记录重复提交表单;</p>\n	</li>\n	<li>\n	<p>浏览器重复的HTTP请;</p>\n	</li>\n	<li>\n	<p>nginx重发等情况;</p>\n	</li>\n	<li>\n	<p>分布式RPC的try重发等;</p>\n	</li>\n</ul>\n\n<h1><a name=\"t2\"></a><a name=\"t2\"></a>3.解决方案</h1>\n\n<p><strong>1)前端js提交禁止按钮可以用一些js组件</strong></p>\n\n<p><strong>2)使用Post/Redirect/Get模式</strong></p>\n\n<p>在提交后执行页面重定向，这就是所谓的Post-Redirect-Get (PRG)模式。简言之，当用户提交了表单后，你去执行一个客户端的重定向，转到提交成功信息页面。这能避免用户按F5导致的重复提交，而其也不会出现浏览器表单重复提交的警告，也能消除按浏览器前进和后退按导致的同样问题。</p>\n\n<p><strong>3)在session中存放一个特殊标志</strong></p>\n\n<p>在服务器端，生成一个唯一的标识符，将它存入session，同时将它写入表单的隐藏字段中，然后将表单页面发给浏览器，用户录入信息后点击提交，在服务器端，获取表单中隐藏字段的值，与session中的唯一标识符比较，相等说明是首次提交，就处理本次请求，然后将session中的唯一标识符移除；不相等说明是重复提交，就不再处理。</p>\n\n<p><strong>4)其他借助使用header头设置缓存控制头Cache-control等方式</strong></p>\n\n<p>比较复杂 不适合移动端APP的应用 这里不详解</p>\n\n<p><strong>5)借助数据库</strong></p>\n\n<p>insert使用唯一索引 update使用 乐观锁 version版本法</p>\n\n<p>这种在大数据量和高并发下效率依赖数据库硬件能力,可针对非核心业务</p>\n\n<p><strong>6)借助悲观锁</strong></p>\n\n<p>使用select &hellip; for update ,这种和 synchronized 锁住先查再insert or update一样,但要避免死锁,效率也较差</p>\n\n<p>针对单体 请求并发不大 可以推荐使用</p>\n\n<p><strong>7)借助本地锁(本文重点)</strong></p>\n\n<p>原理:</p>\n\n<p>使用了 ConcurrentHashMap 并发容器 putIfAbsent 方法,和 ScheduledThreadPoolExecutor 定时任务,也可以使用guava cache的机制, gauva中有配有缓存的有效时间也是可以的key的生成</p>\n\n<p>Content-MD5</p>\n\n<p>Content-MD5 是指 Body 的 MD5 值，只有当 Body 非Form表单时才计算MD5，计算方式直接将参数和参数名称统一加密MD5</p>\n\n<p>MD5在一定范围类认为是唯一的 近似唯一 当然在低并发的情况下足够了</p>\n\n<p>本地锁只适用于单机部署的应用.</p>\n\n<h1><a name=\"t3\"></a><a name=\"t3\"></a>①配置注解</h1>\n\n<pre>\n\n&nbsp;</pre>\n\n<ol>\n	<li>\n	<p><code>import java.lang.annotation.*;</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>@Target(ElementType.METHOD)</code></p>\n	</li>\n	<li>\n	<p><code>@Retention(RetentionPolicy.RUNTIME)</code></p>\n	</li>\n	<li>\n	<p><code>@Documented</code></p>\n	</li>\n	<li>\n	<p><code>public @interface Resubmit {</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>/**</code></p>\n	</li>\n	<li>\n	<p><code>* 延时时间 在延时多久后可以再次提交</code></p>\n	</li>\n	<li>\n	<p><code>*</code></p>\n	</li>\n	<li>\n	<p><code>* @return Time unit is one second</code></p>\n	</li>\n	<li>\n	<p><code>*/</code></p>\n	</li>\n	<li>\n	<p><code>int delaySeconds() default 20;</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n</ol>\n\n<h1><a name=\"t4\"></a><a name=\"t4\"></a>②实例化锁</h1>\n\n<pre>\n\n&nbsp;</pre>\n\n<ol>\n	<li>\n	<p><code>import com.google.common.cache.Cache;</code></p>\n	</li>\n	<li>\n	<p><code>import com.google.common.cache.CacheBuilder;</code></p>\n	</li>\n	<li>\n	<p><code>import lombok.extern.slf4j.Slf4j;</code></p>\n	</li>\n	<li>\n	<p><code>import org.apache.commons.codec.digest.DigestUtils;</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>import java.util.Objects;</code></p>\n	</li>\n	<li>\n	<p><code>import java.util.concurrent.ConcurrentHashMap;</code></p>\n	</li>\n	<li>\n	<p><code>import java.util.concurrent.ScheduledThreadPoolExecutor;</code></p>\n	</li>\n	<li>\n	<p><code>import java.util.concurrent.ThreadPoolExecutor;</code></p>\n	</li>\n	<li>\n	<p><code>import java.util.concurrent.TimeUnit;</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>/**</code></p>\n	</li>\n	<li>\n	<p><code>* @author lijing</code></p>\n	</li>\n	<li>\n	<p><code>* 重复提交锁</code></p>\n	</li>\n	<li>\n	<p><code>*/</code></p>\n	</li>\n	<li>\n	<p><code>@Slf4j</code></p>\n	</li>\n	<li>\n	<p><code>public final class ResubmitLock {</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>private static final ConcurrentHashMap&lt;String, Object&gt; LOCK_CACHE = new ConcurrentHashMap&lt;&gt;(200);</code></p>\n	</li>\n	<li>\n	<p><code>private static final ScheduledThreadPoolExecutor EXECUTOR = new ScheduledThreadPoolExecutor(5, new ThreadPoolExecutor.DiscardPolicy());</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>// private static final Cache&lt;String, Object&gt; CACHES = CacheBuilder.newBuilder()</code></p>\n	</li>\n	<li>\n	<p><code>// 最大缓存 100 个</code></p>\n	</li>\n	<li>\n	<p><code>// .maximumSize(1000)</code></p>\n	</li>\n	<li>\n	<p><code>// 设置写缓存后 5 秒钟过期</code></p>\n	</li>\n	<li>\n	<p><code>// .expireAfterWrite(5, TimeUnit.SECONDS)</code></p>\n	</li>\n	<li>\n	<p><code>// .build();</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>private ResubmitLock() {</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>/**</code></p>\n	</li>\n	<li>\n	<p><code>* 静态内部类 单例模式</code></p>\n	</li>\n	<li>\n	<p><code>*</code></p>\n	</li>\n	<li>\n	<p><code>* @return</code></p>\n	</li>\n	<li>\n	<p><code>*/</code></p>\n	</li>\n	<li>\n	<p><code>private static class SingletonInstance {</code></p>\n	</li>\n	<li>\n	<p><code>private static final ResubmitLock INSTANCE = new ResubmitLock();</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>public static ResubmitLock getInstance() {</code></p>\n	</li>\n	<li>\n	<p><code>return SingletonInstance.INSTANCE;</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>public static String handleKey(String param) {</code></p>\n	</li>\n	<li>\n	<p><code>return DigestUtils.md5Hex(param == null ? &quot;&quot; : param);</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>/**</code></p>\n	</li>\n	<li>\n	<p><code>* 加锁 putIfAbsent 是原子操作保证线程安全</code></p>\n	</li>\n	<li>\n	<p><code>*</code></p>\n	</li>\n	<li>\n	<p><code>* @param key 对应的key</code></p>\n	</li>\n	<li>\n	<p><code>* @param value</code></p>\n	</li>\n	<li>\n	<p><code>* @return</code></p>\n	</li>\n	<li>\n	<p><code>*/</code></p>\n	</li>\n	<li>\n	<p><code>public boolean lock(final String key, Object value) {</code></p>\n	</li>\n	<li>\n	<p><code>return Objects.isNull(LOCK_CACHE.putIfAbsent(key, value));</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>/**</code></p>\n	</li>\n	<li>\n	<p><code>* 延时释放锁 用以控制短时间内的重复提交</code></p>\n	</li>\n	<li>\n	<p><code>*</code></p>\n	</li>\n	<li>\n	<p><code>* @param lock 是否需要解锁</code></p>\n	</li>\n	<li>\n	<p><code>* @param key 对应的key</code></p>\n	</li>\n	<li>\n	<p><code>* @param delaySeconds 延时时间</code></p>\n	</li>\n	<li>\n	<p><code>*/</code></p>\n	</li>\n	<li>\n	<p><code>public void unLock(final boolean lock, final String key, final int delaySeconds) {</code></p>\n	</li>\n	<li>\n	<p><code>if (lock) {</code></p>\n	</li>\n	<li>\n	<p><code>EXECUTOR.schedule(() -&gt; {</code></p>\n	</li>\n	<li>\n	<p><code>LOCK_CACHE.remove(key);</code></p>\n	</li>\n	<li>\n	<p><code>}, delaySeconds, TimeUnit.SECONDS);</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n</ol>\n\n<h1><a name=\"t5\"></a><a name=\"t5\"></a>③AOP 切面</h1>\n\n<pre>\n\n&nbsp;</pre>\n\n<ol>\n	<li>\n	<p><code>import com.alibaba.fastjson.JSONObject;</code></p>\n	</li>\n	<li>\n	<p><code>import com.cn.xxx.common.annotation.Resubmit;</code></p>\n	</li>\n	<li>\n	<p><code>import com.cn.xxx.common.annotation.impl.ResubmitLock;</code></p>\n	</li>\n	<li>\n	<p><code>import com.cn.xxx.common.dto.RequestDTO;</code></p>\n	</li>\n	<li>\n	<p><code>import com.cn.xxx.common.dto.ResponseDTO;</code></p>\n	</li>\n	<li>\n	<p><code>import com.cn.xxx.common.enums.ResponseCode;</code></p>\n	</li>\n	<li>\n	<p><code>import lombok.extern.log4j.Log4j;</code></p>\n	</li>\n	<li>\n	<p><code>import org.aspectj.lang.ProceedingJoinPoint;</code></p>\n	</li>\n	<li>\n	<p><code>import org.aspectj.lang.annotation.Around;</code></p>\n	</li>\n	<li>\n	<p><code>import org.aspectj.lang.annotation.Aspect;</code></p>\n	</li>\n	<li>\n	<p><code>import org.aspectj.lang.reflect.MethodSignature;</code></p>\n	</li>\n	<li>\n	<p><code>import org.springframework.stereotype.Component;</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>import java.lang.reflect.Method;</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>/**</code></p>\n	</li>\n	<li>\n	<p><code>* @ClassName RequestDataAspect</code></p>\n	</li>\n	<li>\n	<p><code>* @Description 数据重复提交校验</code></p>\n	</li>\n	<li>\n	<p><code>* @Author lijing</code></p>\n	</li>\n	<li>\n	<p><code>* @Date 2019/05/16 17:05</code></p>\n	</li>\n	<li>\n	<p><code>**/</code></p>\n	</li>\n	<li>\n	<p><code>@Log4j</code></p>\n	</li>\n	<li>\n	<p><code>@Aspect</code></p>\n	</li>\n	<li>\n	<p><code>@Component</code></p>\n	</li>\n	<li>\n	<p><code>public class ResubmitDataAspect {</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>private final static String DATA = &quot;data&quot;;</code></p>\n	</li>\n	<li>\n	<p><code>private final static Object PRESENT = new Object();</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>@Around(&quot;@annotation(com.cn.xxx.common.annotation.Resubmit)&quot;)</code></p>\n	</li>\n	<li>\n	<p><code>public Object handleResubmit(ProceedingJoinPoint joinPoint) throws Throwable {</code></p>\n	</li>\n	<li>\n	<p><code>Method method = ((MethodSignature) joinPoint.getSignature()).getMethod();</code></p>\n	</li>\n	<li>\n	<p><code>//获取注解信息</code></p>\n	</li>\n	<li>\n	<p><code>Resubmit annotation = method.getAnnotation(Resubmit.class);</code></p>\n	</li>\n	<li>\n	<p><code>int delaySeconds = annotation.delaySeconds();</code></p>\n	</li>\n	<li>\n	<p><code>Object[] pointArgs = joinPoint.getArgs();</code></p>\n	</li>\n	<li>\n	<p><code>String key = &quot;&quot;;</code></p>\n	</li>\n	<li>\n	<p><code>//获取第一个参数</code></p>\n	</li>\n	<li>\n	<p><code>Object firstParam = pointArgs[0];</code></p>\n	</li>\n	<li>\n	<p><code>if (firstParam instanceof RequestDTO) {</code></p>\n	</li>\n	<li>\n	<p><code>//解析参数</code></p>\n	</li>\n	<li>\n	<p><code>JSONObject requestDTO = JSONObject.parseObject(firstParam.toString());</code></p>\n	</li>\n	<li>\n	<p><code>JSONObject data = JSONObject.parseObject(requestDTO.getString(DATA));</code></p>\n	</li>\n	<li>\n	<p><code>if (data != null) {</code></p>\n	</li>\n	<li>\n	<p><code>StringBuffer sb = new StringBuffer();</code></p>\n	</li>\n	<li>\n	<p><code>data.forEach((k, v) -&gt; {</code></p>\n	</li>\n	<li>\n	<p><code>sb.append(v);</code></p>\n	</li>\n	<li>\n	<p><code>});</code></p>\n	</li>\n	<li>\n	<p><code>//生成加密参数 使用了content_MD5的加密方式</code></p>\n	</li>\n	<li>\n	<p><code>key = ResubmitLock.handleKey(sb.toString());</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>\n	<p><code>//执行锁</code></p>\n	</li>\n	<li>\n	<p><code>boolean lock = false;</code></p>\n	</li>\n	<li>\n	<p><code>try {</code></p>\n	</li>\n	<li>\n	<p><code>//设置解锁key</code></p>\n	</li>\n	<li>\n	<p><code>lock = ResubmitLock.getInstance().lock(key, PRESENT);</code></p>\n	</li>\n	<li>\n	<p><code>if (lock) {</code></p>\n	</li>\n	<li>\n	<p><code>//放行</code></p>\n	</li>\n	<li>\n	<p><code>return joinPoint.proceed();</code></p>\n	</li>\n	<li>\n	<p><code>} else {</code></p>\n	</li>\n	<li>\n	<p><code>//响应重复提交异常</code></p>\n	</li>\n	<li>\n	<p><code>return new ResponseDTO&lt;&gt;(ResponseCode.REPEAT_SUBMIT_OPERATION_EXCEPTION);</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>\n	<p><code>} finally {</code></p>\n	</li>\n	<li>\n	<p><code>//设置解锁key和解锁时间</code></p>\n	</li>\n	<li>\n	<p><code>ResubmitLock.getInstance().unLock(lock, key, delaySeconds);</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n</ol>\n\n<h1><a name=\"t6\"></a><a name=\"t6\"></a>④注解使用案例</h1>\n\n<pre>\n\n&nbsp;</pre>\n\n<ol>\n	<li>\n	<p><code>@ApiOperation(value = &quot;保存我的帖子接口&quot;, notes = &quot;保存我的帖子接口&quot;)</code></p>\n	</li>\n	<li>\n	<p><code>@PostMapping(&quot;/posts/save&quot;)</code></p>\n	</li>\n	<li>\n	<p><code>@Resubmit(delaySeconds = 10)</code></p>\n	</li>\n	<li>\n	<p><code>public ResponseDTO&lt;BaseResponseDataDTO&gt; saveBbsPosts(@RequestBody @Validated RequestDTO&lt;BbsPostsRequestDTO&gt; requestDto) {</code></p>\n	</li>\n	<li>\n	<p><code>return bbsPostsBizService.saveBbsPosts(requestDto);</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n</ol>\n\n<p>以上就是本地锁的方式进行的幂等提交 使用了Content-MD5 进行加密 只要参数不变,参数加密 密值不变,key存在就阻止提交</p>\n\n<p>当然也可以使用 一些其他签名校验 在某一次提交时先 生成固定签名 提交到后端 根据后端解析统一的签名作为 每次提交的验证token 去缓存中处理即可.</p>\n\n<p><strong>8)借助分布式<a href=\"https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;mid=2247488260&amp;idx=3&amp;sn=6d626c5ba127951a8230dd1645f6bfc3&amp;scene=21#wechat_redirect\">redis</a>锁 （参考其他）</strong></p>\n\n<p>在 pom.xml 中添加上 starter-web、starter-aop、starter-data-<a href=\"https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;mid=2247488260&amp;idx=3&amp;sn=6d626c5ba127951a8230dd1645f6bfc3&amp;scene=21#wechat_redirect\">redis</a>&nbsp;的依赖即可</p>\n\n<pre>\n\n&nbsp;</pre>\n\n<ol>\n	<li>\n	<p><code>&lt;dependencies&gt;</code></p>\n	</li>\n	<li>\n	<p><code>&lt;dependency&gt;</code></p>\n	</li>\n	<li>\n	<p><code>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</code></p>\n	</li>\n	<li>\n	<p><code>&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</code></p>\n	</li>\n	<li>\n	<p><code>&lt;/dependency&gt;</code></p>\n	</li>\n	<li>\n	<p><code>&lt;dependency&gt;</code></p>\n	</li>\n	<li>\n	<p><code>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</code></p>\n	</li>\n	<li>\n	<p><code>&lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</code></p>\n	</li>\n	<li>\n	<p><code>&lt;/dependency&gt;</code></p>\n	</li>\n	<li>\n	<p><code>&lt;dependency&gt;</code></p>\n	</li>\n	<li>\n	<p><code>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</code></p>\n	</li>\n	<li>\n	<p><code>&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</code></p>\n	</li>\n	<li>\n	<p><code>&lt;/dependency&gt;</code></p>\n	</li>\n	<li>\n	<p><code>&lt;/dependencies&gt;</code></p>\n	</li>\n</ol>\n\n<p>属性配置 在 application.properites 资源文件中添加&nbsp;<a href=\"https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;mid=2247488260&amp;idx=3&amp;sn=6d626c5ba127951a8230dd1645f6bfc3&amp;scene=21#wechat_redirect\">redis</a>&nbsp;相关的配置项</p>\n\n<pre>\n\n&nbsp;</pre>\n\n<ol>\n	<li>\n	<p><code>spring.redis.host=localhost</code></p>\n	</li>\n	<li>\n	<p><code>spring.redis.port=6379</code></p>\n	</li>\n	<li>\n	<p><code>spring.redis.password=123456</code></p>\n	</li>\n</ol>\n\n<p><strong>主要实现方式:</strong></p>\n\n<p>熟悉&nbsp;<a href=\"https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;mid=2247488260&amp;idx=3&amp;sn=6d626c5ba127951a8230dd1645f6bfc3&amp;scene=21#wechat_redirect\">Redis</a>&nbsp;的朋友都知道它是线程安全的，我们利用它的特性可以很轻松的实现一个分布式锁，如 opsForValue().setIfAbsent(key,value)它的作用就是如果缓存中没有当前 Key 则进行缓存同时返回 true 反之亦然；</p>\n\n<p>当缓存后给 key 在设置个过期时间，防止因为系统崩溃而导致锁迟迟不释放形成死锁；那么我们是不是可以这样认为当返回 true 我们认为它获取到锁了，在锁未释放的时候我们进行异常的抛出&hellip;</p>\n\n<pre>\n\n&nbsp;</pre>\n\n<ol>\n	<li>\n	<p><code>package com.battcn.interceptor;</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>import com.battcn.annotation.CacheLock;</code></p>\n	</li>\n	<li>\n	<p><code>import com.battcn.utils.RedisLockHelper;</code></p>\n	</li>\n	<li>\n	<p><code>import org.aspectj.lang.ProceedingJoinPoint;</code></p>\n	</li>\n	<li>\n	<p><code>import org.aspectj.lang.annotation.Around;</code></p>\n	</li>\n	<li>\n	<p><code>import org.aspectj.lang.annotation.Aspect;</code></p>\n	</li>\n	<li>\n	<p><code>import org.aspectj.lang.reflect.MethodSignature;</code></p>\n	</li>\n	<li>\n	<p><code>import org.springframework.beans.factory.annotation.Autowired;</code></p>\n	</li>\n	<li>\n	<p><code>import org.springframework.context.annotation.Configuration;</code></p>\n	</li>\n	<li>\n	<p><code>import org.springframework.util.StringUtils;</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>import java.lang.reflect.Method;</code></p>\n	</li>\n	<li>\n	<p><code>import java.util.UUID;</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>/**</code></p>\n	</li>\n	<li>\n	<p><code>* redis 方案</code></p>\n	</li>\n	<li>\n	<p><code>*</code></p>\n	</li>\n	<li>\n	<p><code>* @author Levin</code></p>\n	</li>\n	<li>\n	<p><code>* @since 2018/6/12 0012</code></p>\n	</li>\n	<li>\n	<p><code>*/</code></p>\n	</li>\n	<li>\n	<p><code>@Aspect</code></p>\n	</li>\n	<li>\n	<p><code>@Configuration</code></p>\n	</li>\n	<li>\n	<p><code>public class LockMethodInterceptor {</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>@Autowired</code></p>\n	</li>\n	<li>\n	<p><code>public LockMethodInterceptor(RedisLockHelper redisLockHelper, CacheKeyGenerator cacheKeyGenerator) {</code></p>\n	</li>\n	<li>\n	<p><code>this.redisLockHelper = redisLockHelper;</code></p>\n	</li>\n	<li>\n	<p><code>this.cacheKeyGenerator = cacheKeyGenerator;</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>private final RedisLockHelper redisLockHelper;</code></p>\n	</li>\n	<li>\n	<p><code>private final CacheKeyGenerator cacheKeyGenerator;</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>@Around(&quot;execution(public * *(..)) &amp;&amp; @annotation(com.battcn.annotation.CacheLock)&quot;)</code></p>\n	</li>\n	<li>\n	<p><code>public Object interceptor(ProceedingJoinPoint pjp) {</code></p>\n	</li>\n	<li>\n	<p><code>MethodSignature signature = (MethodSignature) pjp.getSignature();</code></p>\n	</li>\n	<li>\n	<p><code>Method method = signature.getMethod();</code></p>\n	</li>\n	<li>\n	<p><code>CacheLock lock = method.getAnnotation(CacheLock.class);</code></p>\n	</li>\n	<li>\n	<p><code>if (StringUtils.isEmpty(lock.prefix())) {</code></p>\n	</li>\n	<li>\n	<p><code>throw new RuntimeException(&quot;lock key don&#39;t null...&quot;);</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>\n	<p><code>final String lockKey = cacheKeyGenerator.getLockKey(pjp);</code></p>\n	</li>\n	<li>\n	<p><code>String value = UUID.randomUUID().toString();</code></p>\n	</li>\n	<li>\n	<p><code>try {</code></p>\n	</li>\n	<li>\n	<p><code>// 假设上锁成功，但是设置过期时间失效，以后拿到的都是 false</code></p>\n	</li>\n	<li>\n	<p><code>final boolean success = redisLockHelper.lock(lockKey, value, lock.expire(), lock.timeUnit());</code></p>\n	</li>\n	<li>\n	<p><code>if (!success) {</code></p>\n	</li>\n	<li>\n	<p><code>throw new RuntimeException(&quot;重复提交&quot;);</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>\n	<p><code>try {</code></p>\n	</li>\n	<li>\n	<p><code>return pjp.proceed();</code></p>\n	</li>\n	<li>\n	<p><code>} catch (Throwable throwable) {</code></p>\n	</li>\n	<li>\n	<p><code>throw new RuntimeException(&quot;系统异常&quot;);</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>\n	<p><code>} finally {</code></p>\n	</li>\n	<li>\n	<p><code>// TODO 如果演示的话需要注释该代码;实际应该放开</code></p>\n	</li>\n	<li>\n	<p><code>redisLockHelper.unlock(lockKey, value);</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n</ol>\n\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;mid=2247488260&amp;idx=3&amp;sn=6d626c5ba127951a8230dd1645f6bfc3&amp;scene=21#wechat_redirect\">Redis</a>LockHelper 通过封装成 API 方式调用，灵活度更加高</p>\n\n<pre>\n\n&nbsp;</pre>\n\n<ol>\n	<li>\n	<p><code>package com.battcn.utils;</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>import org.springframework.boot.autoconfigure.AutoConfigureAfter;</code></p>\n	</li>\n	<li>\n	<p><code>import org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration;</code></p>\n	</li>\n	<li>\n	<p><code>import org.springframework.context.annotation.Configuration;</code></p>\n	</li>\n	<li>\n	<p><code>import org.springframework.data.redis.connection.RedisStringCommands;</code></p>\n	</li>\n	<li>\n	<p><code>import org.springframework.data.redis.core.RedisCallback;</code></p>\n	</li>\n	<li>\n	<p><code>import org.springframework.data.redis.core.StringRedisTemplate;</code></p>\n	</li>\n	<li>\n	<p><code>import org.springframework.data.redis.core.types.Expiration;</code></p>\n	</li>\n	<li>\n	<p><code>import org.springframework.util.StringUtils;</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>import java.util.concurrent.Executors;</code></p>\n	</li>\n	<li>\n	<p><code>import java.util.concurrent.ScheduledExecutorService;</code></p>\n	</li>\n	<li>\n	<p><code>import java.util.concurrent.TimeUnit;</code></p>\n	</li>\n	<li>\n	<p><code>import java.util.regex.Pattern;</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>/**</code></p>\n	</li>\n	<li>\n	<p><code>* 需要定义成 Bean</code></p>\n	</li>\n	<li>\n	<p><code>*</code></p>\n	</li>\n	<li>\n	<p><code>* @author Levin</code></p>\n	</li>\n	<li>\n	<p><code>* @since 2018/6/15 0015</code></p>\n	</li>\n	<li>\n	<p><code>*/</code></p>\n	</li>\n	<li>\n	<p><code>@Configuration</code></p>\n	</li>\n	<li>\n	<p><code>@AutoConfigureAfter(RedisAutoConfiguration.class)</code></p>\n	</li>\n	<li>\n	<p><code>public class RedisLockHelper {</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>private static final String DELIMITER = &quot;|&quot;;</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>/**</code></p>\n	</li>\n	<li>\n	<p><code>* 如果要求比较高可以通过注入的方式分配</code></p>\n	</li>\n	<li>\n	<p><code>*/</code></p>\n	</li>\n	<li>\n	<p><code>private static final ScheduledExecutorService EXECUTOR_SERVICE = Executors.newScheduledThreadPool(10);</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>private final StringRedisTemplate stringRedisTemplate;</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>public RedisLockHelper(StringRedisTemplate stringRedisTemplate) {</code></p>\n	</li>\n	<li>\n	<p><code>this.stringRedisTemplate = stringRedisTemplate;</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>/**</code></p>\n	</li>\n	<li>\n	<p><code>* 获取锁（存在死锁风险）</code></p>\n	</li>\n	<li>\n	<p><code>*</code></p>\n	</li>\n	<li>\n	<p><code>* @param lockKey lockKey</code></p>\n	</li>\n	<li>\n	<p><code>* @param value value</code></p>\n	</li>\n	<li>\n	<p><code>* @param time 超时时间</code></p>\n	</li>\n	<li>\n	<p><code>* @param unit 过期单位</code></p>\n	</li>\n	<li>\n	<p><code>* @return true or false</code></p>\n	</li>\n	<li>\n	<p><code>*/</code></p>\n	</li>\n	<li>\n	<p><code>public boolean tryLock(final String lockKey, final String value, final long time, final TimeUnit unit) {</code></p>\n	</li>\n	<li>\n	<p><code>return stringRedisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; connection.set(lockKey.getBytes(), value.getBytes(), Expiration.from(time, unit), RedisStringCommands.SetOption.SET_IF_ABSENT));</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>/**</code></p>\n	</li>\n	<li>\n	<p><code>* 获取锁</code></p>\n	</li>\n	<li>\n	<p><code>*</code></p>\n	</li>\n	<li>\n	<p><code>* @param lockKey lockKey</code></p>\n	</li>\n	<li>\n	<p><code>* @param uuid UUID</code></p>\n	</li>\n	<li>\n	<p><code>* @param timeout 超时时间</code></p>\n	</li>\n	<li>\n	<p><code>* @param unit 过期单位</code></p>\n	</li>\n	<li>\n	<p><code>* @return true or false</code></p>\n	</li>\n	<li>\n	<p><code>*/</code></p>\n	</li>\n	<li>\n	<p><code>public boolean lock(String lockKey, final String uuid, long timeout, final TimeUnit unit) {</code></p>\n	</li>\n	<li>\n	<p><code>final long milliseconds = Expiration.from(timeout, unit).getExpirationTimeInMilliseconds();</code></p>\n	</li>\n	<li>\n	<p><code>boolean success = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, (System.currentTimeMillis() + milliseconds) + DELIMITER + uuid);</code></p>\n	</li>\n	<li>\n	<p><code>if (success) {</code></p>\n	</li>\n	<li>\n	<p><code>stringRedisTemplate.expire(lockKey, timeout, TimeUnit.SECONDS);</code></p>\n	</li>\n	<li>\n	<p><code>} else {</code></p>\n	</li>\n	<li>\n	<p><code>String oldVal = stringRedisTemplate.opsForValue().getAndSet(lockKey, (System.currentTimeMillis() + milliseconds) + DELIMITER + uuid);</code></p>\n	</li>\n	<li>\n	<p><code>final String[] oldValues = oldVal.split(Pattern.quote(DELIMITER));</code></p>\n	</li>\n	<li>\n	<p><code>if (Long.parseLong(oldValues[0]) + 1 &lt;= System.currentTimeMillis()) {</code></p>\n	</li>\n	<li>\n	<p><code>return true;</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>\n	<p><code>return success;</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>/**</code></p>\n	</li>\n	<li>\n	<p><code>* @see &lt;a href=&quot;http://redis.io/commands/set&quot;&gt;Redis Documentation: SET&lt;/a&gt;</code></p>\n	</li>\n	<li>\n	<p><code>*/</code></p>\n	</li>\n	<li>\n	<p><code>public void unlock(String lockKey, String value) {</code></p>\n	</li>\n	<li>\n	<p><code>unlock(lockKey, value, 0, TimeUnit.MILLISECONDS);</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>/**</code></p>\n	</li>\n	<li>\n	<p><code>* 延迟unlock</code></p>\n	</li>\n	<li>\n	<p><code>*</code></p>\n	</li>\n	<li>\n	<p><code>* @param lockKey key</code></p>\n	</li>\n	<li>\n	<p><code>* @param uuid client(最好是唯一键的)</code></p>\n	</li>\n	<li>\n	<p><code>* @param delayTime 延迟时间</code></p>\n	</li>\n	<li>\n	<p><code>* @param unit 时间单位</code></p>\n	</li>\n	<li>\n	<p><code>*/</code></p>\n	</li>\n	<li>\n	<p><code>public void unlock(final String lockKey, final String uuid, long delayTime, TimeUnit unit) {</code></p>\n	</li>\n	<li>\n	<p><code>if (StringUtils.isEmpty(lockKey)) {</code></p>\n	</li>\n	<li>\n	<p><code>return;</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>\n	<p><code>if (delayTime &lt;= 0) {</code></p>\n	</li>\n	<li>\n	<p><code>doUnlock(lockKey, uuid);</code></p>\n	</li>\n	<li>\n	<p><code>} else {</code></p>\n	</li>\n	<li>\n	<p><code>EXECUTOR_SERVICE.schedule(() -&gt; doUnlock(lockKey, uuid), delayTime, unit);</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>/**</code></p>\n	</li>\n	<li>\n	<p><code>* @param lockKey key</code></p>\n	</li>\n	<li>\n	<p><code>* @param uuid client(最好是唯一键的)</code></p>\n	</li>\n	<li>\n	<p><code>*/</code></p>\n	</li>\n	<li>\n	<p><code>private void doUnlock(final String lockKey, final String uuid) {</code></p>\n	</li>\n	<li>\n	<p><code>String val = stringRedisTemplate.opsForValue().get(lockKey);</code></p>\n	</li>\n	<li>\n	<p><code>final String[] values = val.split(Pattern.quote(DELIMITER));</code></p>\n	</li>\n	<li>\n	<p><code>if (values.length &lt;= 0) {</code></p>\n	</li>\n	<li>\n	<p><code>return;</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>\n	<p><code>if (uuid.equals(values[1])) {</code></p>\n	</li>\n	<li>\n	<p><code>stringRedisTemplate.delete(lockKey);</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n	<li>&nbsp;</li>\n	<li>\n	<p><code>}</code></p>\n	</li>\n</ol>\n\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;mid=2247488260&amp;idx=3&amp;sn=6d626c5ba127951a8230dd1645f6bfc3&amp;scene=21#wechat_redirect\">redis</a>的提交参照</p>\n\n<blockquote>\n<p>https://blog.battcn.com/2018/06/13/<a href=\"https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;mid=2247486264&amp;idx=1&amp;sn=475ac3f1ef253a33daacf50477203c80&amp;scene=21#wechat_redirect\">springboot</a>/v2-cache-<a href=\"https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;mid=2247488260&amp;idx=3&amp;sn=6d626c5ba127951a8230dd1645f6bfc3&amp;scene=21#wechat_redirect\">redis</a>lock/</p>\n</blockquote>\n', '0', '0', null, null, null, '1589363031002', '0', '1', null);
INSERT INTO `boke_boke` VALUES ('ef9e5a24ff9b40879fbd0e40435ea783', 'Android多线程之Handler', '', 'Android--多线程之Handler', 'BOKE202004289255', 'a8d54e799fa04d4f9f5f8d795638d2bd', '1588053254192', '0', '0', '<p><strong>前言</strong></p>\n\n<p>　　Android的消息传递机制是另外一种形式的&ldquo;事件处理&rdquo;，这种机制主要是为了解决Android应用中多线程的问题，在Android中不允许Activity新启动的线程访问该Activity里的UI组件，这样会导致新启动的线程无法改变UI组件的属性值。但实际开发中，很多地方需要在工作线程中改变UI组件的属性值，比如下载网络图片、动画等等。本篇博客主要介绍Handler是如何发送与处理线程上传递来的消息，并讲解Message的几种传递数据的方式，最后均会以小Demo来演示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>Handler</strong></p>\n\n<p>　　<a href=\"http://developer.android.com/reference/android/os/Handler.html\" target=\"_blank\">Handler</a>，它直接继承自Object，一个Handler允许发送和处理Message或者Runnable对象，并且会关联到主线程的MessageQueue中。每个Handler具有一个单独的线程，并且关联到一个消息队列的线程，就是说一个Handler有一个固有的消息队列。当实例化一个Handler的时候，它就承载在一个线程和消息队列的线程，这个Handler可以把Message或Runnable压入到消息队列，并且从消息队列中取出Message或Runnable，进而操作它们。</p>\n\n<p>　　Handler主要有两个作用：</p>\n\n<ul>\n	<li>在工作线程中发送消息。</li>\n	<li>在UI线程中获取、处理消息。</li>\n</ul>\n\n<p>　　上面介绍到Handler可以把一个Message对象或者Runnable对象压入到消息队列中，进而在UI线程中获取Message或者执行Runnable对象，所以Handler把压入消息队列有两大体系，Post和sendMessage：</p>\n\n<ul>\n	<li>Post：Post允许把一个Runnable对象入队到消息队列中。它的方法有：post(Runnable)、postAtTime(Runnable,long)、postDelayed(Runnable,long)。</li>\n	<li>sendMessage：sendMessage允许把一个包含消息数据的Message对象压入到消息队列中。它的方法有：sendEmptyMessage(int)、sendMessage(Message)、sendMessageAtTime(Message,long)、sendMessageDelayed(Message,long)。</li>\n</ul>\n\n<p>　　从上面的各种方法可以看出，不管是post还是sendMessage都具有多种方法，它们可以设定Runnable对象和Message对象被入队到消息队列中，是立即执行还是延迟执行。</p>\n\n<p>　　</p>\n\n<p><strong>Post</strong></p>\n\n<p>　　对于Handler的Post方式来说，它会传递一个Runnable对象到消息队列中，在这个Runnable对象中，重写run()方法。一般在这个run()方法中写入需要在UI线程上的操作。</p>\n\n<p>　　在Handler中，关于Post方式的方法有：</p>\n\n<ul>\n	<li>boolean post(Runnable r)：把一个Runnable入队到消息队列中，UI线程从消息队列中取出这个对象后，立即执行。</li>\n	<li>boolean postAtTime(Runnable r,long uptimeMillis)：把一个Runnable入队到消息队列中，UI线程从消息队列中取出这个对象后，在特定的时间执行。</li>\n	<li>boolean postDelayed(Runnable r,long delayMillis)：把一个Runnable入队到消息队列中，UI线程从消息队列中取出这个对象后，延迟delayMills秒执行</li>\n	<li>void removeCallbacks(Runnable r)：从消息队列中移除一个Runnable对象。</li>\n</ul>\n\n<p>&nbsp;　　下面通过一个Demo，讲解如何通过Handler的post方式在新启动的线程中修改UI组件的属性：</p>\n\n<p><a href=\"javascript:void(0);\" onclick=\"copyCnblogsCode(this)\"><img alt=\"复制代码\" src=\"https://common.cnblogs.com/images/copycode.gif\" /></a></p>\n\n<pre>\n 1 package com.bgxt.datatimepickerdemo;\n 2 \n 3 import android.app.Activity;\n 4 import android.os.Bundle;\n 5 import android.os.Handler;\n 6 import android.view.View;\n 7 import android.widget.Button;\n 8 import android.widget.TextView;\n 9 \n10 public class HandlerPostActivity1 extends Activity {\n11     private Button btnMes1,btnMes2;\n12     private TextView tvMessage;\n13     // 声明一个Handler对象\n14     private static Handler handler=new Handler();\n15     \n16     @Override\n17     protected void onCreate(Bundle savedInstanceState) {\n18         super.onCreate(savedInstanceState);\n19         setContentView(R.layout.message_activity);        \n20         \n21         btnMes1=(Button)findViewById(R.id.btnMes1);\n22         btnMes2=(Button)findViewById(R.id.btnMes2);\n23         tvMessage=(TextView)findViewById(R.id.tvMessage);\n24         btnMes1.setOnClickListener(new View.OnClickListener() {\n25             \n26             @Override\n27             public void onClick(View v) {\n28                 // 新启动一个子线程\n29                 new Thread(new Runnable() {                    \n30                     @Override\n31                     public void run() {\n32                         // tvMessage.setText(&quot;...&quot;);\n33                         // 以上操作会报错，无法再子线程中访问UI组件，UI组件的属性必须在UI线程中访问\n34                         // 使用post方式修改UI组件tvMessage的Text属性\n35                         handler.post(new Runnable() {                    \n36                             @Override\n37                             public void run() {\n38                                 tvMessage.setText(&quot;使用Handler.post在工作线程中发送一段执行到消息队列中，在主线程中执行。&quot;);                        \n39                             }\n40                         });                                \n41                     }\n42                 }).start();\n43             }\n44         });\n45         \n46         btnMes2.setOnClickListener(new View.OnClickListener() {\n47             \n48             @Override\n49             public void onClick(View v) {\n50                 new Thread(new Runnable() {                    \n51                     @Override\n52                     public void run() {\n53                         // 使用postDelayed方式修改UI组件tvMessage的Text属性值\n54                         // 并且延迟3S执行\n55                         handler.postDelayed(new Runnable() {\n56                             \n57                             @Override\n58                             public void run() {\n59                                 tvMessage.setText(&quot;使用Handler.postDelayed在工作线程中发送一段执行到消息队列中，在主线程中延迟3S执行。&quot;);    \n60                                 \n61                             }\n62                         }, 3000);                        \n63                     }\n64                 }).start();\n65                 \n66             }\n67         });\n68     }\n69 }</pre>\n\n<p><a href=\"javascript:void(0);\" onclick=\"copyCnblogsCode(this)\"><img alt=\"复制代码\" src=\"https://common.cnblogs.com/images/copycode.gif\" /></a></p>\n\n<p>　　效果展示：</p>\n\n<p><img alt=\"\" src=\"https://images0.cnblogs.com/blog/234895/201308/18181621-374e3409461f439c897365e18b614d8a.x-png\" /><img alt=\"\" src=\"https://images0.cnblogs.com/blog/234895/201308/18181647-20bb326b9ef448b19355012b2067e644.x-png\" /></p>\n\n<p>　　有一点值得注意的是，对于Post方式而言，它其中Runnable对象的run()方法的代码，均执行在UI线程上，所以对于这段代码而言，不能执行在UI线程上的操作，一样无法使用post方式执行，比如说访问网络，下面提供一个例子，使用post方式从互联网上获取一张图片，并且显示在ImageView中。</p>\n\n<p><a href=\"javascript:void(0);\" onclick=\"copyCnblogsCode(this)\"><img alt=\"复制代码\" src=\"https://common.cnblogs.com/images/copycode.gif\" /></a></p>\n\n<pre>\n 1 package com.bgxt.datatimepickerdemo;\n 2 \n 3 import org.apache.http.HttpResponse;\n 4 import org.apache.http.client.HttpClient;\n 5 import org.apache.http.client.methods.HttpGet;\n 6 import org.apache.http.impl.client.DefaultHttpClient;\n 7 import org.apache.http.util.EntityUtils;\n 8 \n 9 import android.app.Activity;\n10 import android.app.ProgressDialog;\n11 import android.graphics.Bitmap;\n12 import android.graphics.BitmapFactory;\n13 import android.os.Bundle;\n14 import android.os.Handler;\n15 import android.view.View;\n16 import android.widget.Button;\n17 import android.widget.ImageView;\n18 \n19 public class HandlerPostActivity2 extends Activity {\n20     private Button btnDown;\n21     private ImageView ivImage;\n22     private static String image_path = &quot;http://ww4.sinaimg.cn/bmiddle/786013a5jw1e7akotp4bcj20c80i3aao.jpg&quot;;\n23     private ProgressDialog dialog;\n24     // 一个静态的Handler，Handler建议声明为静态的\n25     private static  Handler handler=new Handler();\n26     @Override\n27     protected void onCreate(Bundle savedInstanceState) {\n28         super.onCreate(savedInstanceState);\n29         setContentView(R.layout.asynctask_activity);\n30         \n31         btnDown = (Button) findViewById(R.id.btnDown);\n32         ivImage = (ImageView) findViewById(R.id.ivSinaImage);\n33 \n34         dialog = new ProgressDialog(this);\n35         dialog.setTitle(&quot;提示&quot;);\n36         dialog.setMessage(&quot;正在下载，请稍后...&quot;);\n37         dialog.setCancelable(false);\n38         \n39         btnDown.setOnClickListener(new View.OnClickListener() {            \n40             @Override\n41             public void onClick(View v) {\n42                 // 开启一个子线程，用于下载图片\n43                 new Thread(new MyThread()).start();\n44                 // 显示对话框\n45                 dialog.show();\n46             }\n47         });\n48     }\n49     \n50     public class MyThread implements Runnable {\n51 \n52         @Override\n53         public void run() {\n54             // 下载一个图片\n55             HttpClient httpClient = new DefaultHttpClient();\n56             HttpGet httpGet = new HttpGet(image_path);\n57             HttpResponse httpResponse = null;\n58             try {\n59                 httpResponse = httpClient.execute(httpGet);\n60                 if (httpResponse.getStatusLine().getStatusCode() == 200) {\n61                     byte[] data = EntityUtils.toByteArray(httpResponse\n62                             .getEntity());\n63                     // 得到一个Bitmap对象，并且为了使其在post内部可以访问，必须声明为final\n64                     final Bitmap bmp=BitmapFactory.decodeByteArray(data, 0, data.length);\n65                     handler.post(new Runnable() {                        \n66                         @Override\n67                         public void run() {\n68                             // 在Post中操作UI组件ImageView\n69                             ivImage.setImageBitmap(bmp);\n70                         }\n71                     });\n72                     // 隐藏对话框\n73                     dialog.dismiss();\n74                 }\n75             } catch (Exception e) {\n76                 e.printStackTrace();\n77             }\n78         }\n79 \n80     }\n81 }</pre>\n\n<p><a href=\"javascript:void(0);\" onclick=\"copyCnblogsCode(this)\"><img alt=\"复制代码\" src=\"https://common.cnblogs.com/images/copycode.gif\" /></a></p>\n\n<p>&nbsp;　　效果展示：</p>\n\n<p><img alt=\"\" src=\"https://images0.cnblogs.com/blog/234895/201308/18181733-3101871caea1429094c9740fdf5dd63e.x-png\" /><img alt=\"\" src=\"https://images0.cnblogs.com/blog/234895/201308/18181759-82e2ddb4ade84d9eafb26507bef8fc27.x-png\" /><img alt=\"\" src=\"https://images0.cnblogs.com/blog/234895/201308/18181819-e75f3b605d5c43159324a7d521346dd7.x-png\" /></p>\n\n<p>&nbsp;</p>\n\n<p><strong>Message</strong></p>\n\n<p>　　Handler如果使用sendMessage的方式把消息入队到消息队列中，需要传递一个Message对象，而在Handler中，需要重写handleMessage()方法，用于获取工作线程传递过来的消息，此方法运行在UI线程上。下面先介绍一下Message。</p>\n\n<p>　　<a href=\"http://developer.android.com/reference/android/os/Message.html\" target=\"_blank\">Message</a>是一个final类，所以不可被继承。Message封装了线程中传递的消息，如果对于一般的数据，Message提供了getData()和setData()方法来获取与设置数据，其中操作的数据是一个<a href=\"http://developer.android.com/reference/android/os/Bundle.html\" target=\"_blank\">Bundle</a>对象，这个Bundle对象提供一系列的getXxx()和setXxx()方法用于传递基本数据类型的键值对，对于基本数据类型，使用起来很简单，这里不再详细讲解。而对于复杂的数据类型，如一个对象的传递就要相对复杂一些。在Bundle中提供了两个方法，专门用来传递对象的，但是这两个方法也有相应的限制，需要实现特定的接口，当然，一些Android自带的类，其实已经实现了这两个接口中的某一个，可以直接使用。方法如下：</p>\n\n<ul>\n	<li>putParcelable(String key,Parcelable value)：需要传递的对象类实现Parcelable接口。</li>\n	<li>pubSerializable(String key,Serializable value)：需要传递的对象类实现Serializable接口。</li>\n</ul>\n\n<p>　　还有另外一种方式在Message中传递对象，那就是使用Message自带的obj属性传值，它是一个Object类型，所以可以传递任意类型的对象，<a href=\"http://developer.android.com/reference/android/os/Message.html\" target=\"_blank\">Message</a>自带的有如下几个属性：</p>\n\n<ul>\n	<li>int arg1：参数一，用于传递不复杂的数据，复杂数据使用setData()传递。</li>\n	<li>int arg2：参数二，用于传递不复杂的数据，复杂数据使用setData()传递。</li>\n	<li>Object obj：传递一个任意的对象。</li>\n	<li>int what：定义的消息码，一般用于设定消息的标志。</li>\n</ul>\n\n<p>&nbsp;　　对于Message对象，一般并不推荐直接使用它的构造方法得到，而是建议通过使用Message.obtain()这个静态的方法或者Handler.obtainMessage()获取。Message.obtain()会从消息池中获取一个Message对象，如果消息池中是空的，才会使用构造方法实例化一个新Message，这样有利于消息资源的利用。并不需要担心消息池中的消息过多，它是有上限的，上限为10个。Handler.obtainMessage()具有多个重载方法，如果查看源码，会发现其实Handler.obtainMessage()在内部也是调用的Message.obtain()。　　</p>\n\n<p>　　既然Message是在线程间传递消息，那么先以一个Demo讲解一下Message的使用，还是常规的从互联网上下载一张图片的Demo，下载后使用ImageView控件展示：</p>\n\n<p><a href=\"javascript:void(0);\" onclick=\"copyCnblogsCode(this)\"><img alt=\"复制代码\" src=\"https://common.cnblogs.com/images/copycode.gif\" /></a></p>\n\n<pre>\n 1 package com.bgxt.datatimepickerdemo;\n 2 \n 3 import org.apache.http.HttpResponse;\n 4 import org.apache.http.client.HttpClient;\n 5 import org.apache.http.client.methods.HttpGet;\n 6 import org.apache.http.impl.client.DefaultHttpClient;\n 7 import org.apache.http.util.EntityUtils;\n 8 \n 9 import android.app.Activity;\n10 import android.app.ProgressDialog;\n11 import android.graphics.Bitmap;\n12 import android.graphics.BitmapFactory;\n13 import android.os.Bundle;\n14 import android.os.Handler;\n15 import android.os.Message;\n16 import android.view.View;\n17 import android.widget.Button;\n18 import android.widget.ImageView;\n19 \n20 public class HandlerMessageActivity1 extends Activity {\n21     private Button btnDown;\n22     private ImageView ivImage;\n23     private static String image_path = &quot;http://ww4.sinaimg.cn/bmiddle/786013a5jw1e7akotp4bcj20c80i3aao.jpg&quot;;\n24     private ProgressDialog dialog;\n25     private static int IS_FINISH = 1;\n26 \n27     @Override\n28     protected void onCreate(Bundle savedInstanceState) {\n29         super.onCreate(savedInstanceState);\n30         setContentView(R.layout.asynctask_activity);\n31 \n32         btnDown = (Button) findViewById(R.id.btnDown);\n33         ivImage = (ImageView) findViewById(R.id.ivSinaImage);\n34 \n35         dialog = new ProgressDialog(this);\n36         dialog.setTitle(&quot;提示信息&quot;);\n37         dialog.setMessage(&quot;正在下载，请稍后...&quot;);\n38         dialog.setCancelable(false);\n39 \n40         btnDown.setOnClickListener(new View.OnClickListener() {\n41             @Override\n42             public void onClick(View v) {\n43                     new Thread(new MyThread()).start();\n44                     dialog.show();\n45             }\n46         });\n47     }\n48 \n49     private  Handler handler = new Handler() {\n50         // 在Handler中获取消息，重写handleMessage()方法\n51         @Override\n52         public void handleMessage(Message msg) {            \n53             // 判断消息码是否为1\n54             if(msg.what==IS_FINISH){\n55                 byte[] data=(byte[])msg.obj;\n56                 Bitmap bmp=BitmapFactory.decodeByteArray(data, 0, data.length);\n57                 ivImage.setImageBitmap(bmp);\n58                 dialog.dismiss();\n59             }\n60         }\n61     };\n62 \n63     public class MyThread implements Runnable {\n64 \n65         @Override\n66         public void run() {\n67             HttpClient httpClient = new DefaultHttpClient();\n68             HttpGet httpGet = new HttpGet(image_path);\n69             HttpResponse httpResponse = null;\n70             try {\n71                 httpResponse = httpClient.execute(httpGet);\n72                 if (httpResponse.getStatusLine().getStatusCode() == 200) {\n73                     byte[] data = EntityUtils.toByteArray(httpResponse\n74                             .getEntity());\n75                     // 获取一个Message对象，设置what为1\n76                     Message msg = Message.obtain();\n77                     msg.obj = data;\n78                     msg.what = IS_FINISH;\n79                     // 发送这个消息到消息队列中\n80                     handler.sendMessage(msg);\n81                 }\n82             } catch (Exception e) {\n83                 e.printStackTrace();\n84             }\n85         }\n86     }\n87 }</pre>\n\n<p><a href=\"javascript:void(0);\" onclick=\"copyCnblogsCode(this)\"><img alt=\"复制代码\" src=\"https://common.cnblogs.com/images/copycode.gif\" /></a></p>\n\n<p>　　展示效果：</p>\n\n<p><img alt=\"\" src=\"https://images0.cnblogs.com/blog/234895/201308/18181733-3101871caea1429094c9740fdf5dd63e.x-png\" /><img alt=\"\" src=\"https://images0.cnblogs.com/blog/234895/201308/18181759-82e2ddb4ade84d9eafb26507bef8fc27.x-png\" /><img alt=\"\" src=\"https://images0.cnblogs.com/blog/234895/201308/18181819-e75f3b605d5c43159324a7d521346dd7.x-png\" /></p>\n\n<p>　　Message.obtain()方法具有多个重载方法，大致可以分为为两类，一类是无需传递Handler对象，对于这类的方法，当填充好消息后，需要调用Handler.sendMessage()方法来发送消息到消息队列中。第二类需要传递一个Handler对象，这类方法可以直接使用Message.sendToTarget()方法发送消息到消息队列中，这是因为在Message对象中有一个私有的Handler类型的属性Target，当时obtain方法传递进一个Handler对象的时候，会给Target属性赋值，当调用sendToTarget()方法的时候，实际在它内部还是调用的Target.sendMessage()方法。</p>\n\n<p>　　在Handler中，也定义了一些发送空消息的方法，如：sendEmptyMessage(int what)、sendEmptyMessageDelayed(int what,long delayMillis)，看似这些方法没有使用Message就可以发送一个消息，但是如果查看源码就会发现，其实内部也是从Message.obtain()方法中获取一个Message对象，然后给属性赋值，最后使用sendMessage()发送消息到消息队列中。</p>\n\n<p>　　Handler中，与Message发送消息相关的方法有：</p>\n\n<ul>\n	<li>Message obtainMessage()：获取一个Message对象。</li>\n	<li>boolean sendMessage()：发送一个Message对象到消息队列中，并在UI线程取到消息后，立即执行。</li>\n	<li>boolean sendMessageDelayed()：发送一个Message对象到消息队列中，在UI线程取到消息后，延迟执行。</li>\n	<li>boolean sendEmptyMessage(int what)：发送一个空的Message对象到队列中，并在UI线程取到消息后，立即执行。</li>\n	<li>boolean sendEmptyMessageDelayed(int what,long delayMillis)：发送一个空Message对象到消息队列中，在UI线程取到消息后，延迟执行。</li>\n	<li>void removeMessage()：从消息队列中移除一个未响应的消息。</li>\n</ul>\n\n<p>　　下面通过一个小Demo演示一下各种发送Message的方式：</p>\n\n<p><a href=\"javascript:void(0);\" onclick=\"copyCnblogsCode(this)\"><img alt=\"复制代码\" src=\"https://common.cnblogs.com/images/copycode.gif\" /></a></p>\n\n<pre>\n  1 package com.bgxt.datatimepickerdemo;\n  2 \n  3 import android.app.Activity;\n  4 import android.os.Bundle;\n  5 import android.os.Handler;\n  6 import android.os.Message;\n  7 import android.view.View;\n  8 import android.widget.Button;\n  9 import android.widget.TextView;\n 10 \n 11 public class HandlerMessageActivity2 extends Activity {\n 12     private Button btn1, btn2, btn3, btn4,btn5;\n 13     private static TextView tvMes;\n 14     private static Handler handler = new Handler() {\n 15         @Override\n 16         public void handleMessage(android.os.Message msg) {\n 17             if (msg.what == 3||msg.what==5) {\n 18                 tvMes.setText(&quot;what=&quot; + msg.what + &quot;，这是一个空消息&quot;);\n 19             } else {\n 20                 tvMes.setText(&quot;what=&quot; + msg.what + &quot;,&quot; + msg.obj.toString());\n 21             }\n 22 \n 23         };\n 24     };\n 25 \n 26     @Override\n 27     protected void onCreate(Bundle savedInstanceState) {\n 28         // TODO Auto-generated method stub\n 29         super.onCreate(savedInstanceState);\n 30         setContentView(R.layout.message_activity2);\n 31         tvMes = (TextView) findViewById(R.id.tvMes);\n 32         btn1 = (Button) findViewById(R.id.btnMessage1);\n 33         btn2 = (Button) findViewById(R.id.btnMessage2);\n 34         btn3 = (Button) findViewById(R.id.btnMessage3);\n 35         btn4 = (Button) findViewById(R.id.btnMessage4);\n 36         btn5 = (Button) findViewById(R.id.btnMessage5);\n 37 \n 38         btn1.setOnClickListener(new View.OnClickListener() {\n 39             @Override\n 40             public void onClick(View v) {\n 41                 // 使用Message.Obtain+Hander.sendMessage()发送消息\n 42                 new Thread(new Runnable() {\n 43                     @Override\n 44                     public void run() {\n 45                         Message msg = Message.obtain();\n 46                         msg.what = 1;\n 47                         msg.obj = &quot;使用Message.Obtain+Hander.sendMessage()发送消息&quot;;\n 48                         handler.sendMessage(msg);\n 49                     }\n 50                 }).start();\n 51             }\n 52         });\n 53 \n 54         btn2.setOnClickListener(new View.OnClickListener() {\n 55 \n 56             @Override\n 57             public void onClick(View v) {\n 58                 // 使用Message.sendToTarget发送消息\n 59                 new Thread(new Runnable() {\n 60                     @Override\n 61                     public void run() {\n 62                         Message msg = Message.obtain(handler);\n 63                         msg.what = 2;\n 64                         msg.obj = &quot;使用Message.sendToTarget发送消息&quot;;\n 65                         msg.sendToTarget();\n 66                     }\n 67                 }).start();\n 68             }\n 69         });\n 70 \n 71         btn3.setOnClickListener(new View.OnClickListener() {\n 72             // 发送一个延迟消息\n 73             @Override\n 74             public void onClick(View v) {\n 75                 new Thread(new Runnable() {\n 76                     @Override\n 77                     public void run() {\n 78                         handler.sendEmptyMessage(3);\n 79                     }\n 80                 }).start();\n 81             }\n 82         });\n 83 \n 84         btn4.setOnClickListener(new View.OnClickListener() {\n 85 \n 86             @Override\n 87             public void onClick(View v) {\n 88                 new Thread(new Runnable() {\n 89                     @Override\n 90                     public void run() {\n 91                         Message msg = Message.obtain();\n 92                         msg.what =4;\n 93                         msg.obj = &quot;使用Message.Obtain+Hander.sendMessage()发送延迟消息&quot;;\n 94                         handler.sendMessageDelayed(msg, 3000);\n 95                     }\n 96                 }).start();\n 97             }\n 98         });\n 99         \n100         btn5.setOnClickListener(new View.OnClickListener() {\n101             // 发送一个延迟的空消息\n102             @Override\n103             public void onClick(View v) {\n104                 new Thread(new Runnable() {\n105                     @Override\n106                     public void run() {\n107                         handler.sendEmptyMessageDelayed(5, 3000);\n108                     }\n109                 }).start();\n110             }\n111         });\n112     }\n113 }</pre>\n', '0', '0', null, null, null, '1589365470696', '0', '1', null);

-- ----------------------------
-- Table structure for `boke_collect`
-- ----------------------------
DROP TABLE IF EXISTS `boke_collect`;
CREATE TABLE `boke_collect` (
  `collect_id` varchar(32) NOT NULL,
  `user_code` varchar(40) DEFAULT NULL,
  `boke_code` varchar(40) DEFAULT NULL,
  `createtime` datetime DEFAULT NULL,
  PRIMARY KEY (`collect_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of boke_collect
-- ----------------------------

-- ----------------------------
-- Table structure for `boke_comment`
-- ----------------------------
DROP TABLE IF EXISTS `boke_comment`;
CREATE TABLE `boke_comment` (
  `comment_id` varchar(32) NOT NULL,
  `creater` varchar(40) DEFAULT NULL,
  `createtime` datetime DEFAULT NULL,
  `info` varchar(500) DEFAULT NULL,
  `target_type` varchar(40) DEFAULT NULL,
  `target` varchar(32) DEFAULT NULL,
  `who` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`comment_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of boke_comment
-- ----------------------------

-- ----------------------------
-- Table structure for `boke_special`
-- ----------------------------
DROP TABLE IF EXISTS `boke_special`;
CREATE TABLE `boke_special` (
  `special_id` varchar(32) NOT NULL,
  `special_code` varchar(40) NOT NULL,
  `ispublic` varchar(40) DEFAULT NULL,
  `special_name` varchar(40) DEFAULT NULL,
  `info` text,
  `creater` varchar(40) DEFAULT NULL,
  `modtime` bigint(20) DEFAULT NULL,
  `createtime` bigint(20) DEFAULT NULL,
  `isdel` varchar(40) DEFAULT NULL,
  PRIMARY KEY (`special_id`),
  UNIQUE KEY `code` (`special_code`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of boke_special
-- ----------------------------
INSERT INTO `boke_special` VALUES ('27cbd804c8b011e99c9300ffae4ef909', 'SPECIAL20190827000002', '1', '失落古堡', 'string', 'USER20190827000001', null, '20190827161051', '0');
INSERT INTO `boke_special` VALUES ('6b97b79ec8a211e99c9300ffae4ef909', 'SPECIAL20190827000001', '1', '我的散文集', 'string', 'USER20190827000001', null, '20190827161051', '0');
INSERT INTO `boke_special` VALUES ('eaea9b05c93111e99c9300ffae4ef909', 'SPECIAL20190828000001', '1', '神偷奶爸集', '神偷奶爸电影', 'USER20190827000002', null, '20190827161051', '0');

-- ----------------------------
-- Table structure for `boke_type`
-- ----------------------------
DROP TABLE IF EXISTS `boke_type`;
CREATE TABLE `boke_type` (
  `type_id` varchar(32) NOT NULL,
  `type_code` varchar(40) DEFAULT NULL,
  `type_name` varchar(40) DEFAULT NULL,
  `creater` varchar(32) DEFAULT NULL,
  `createtime` bigint(20) DEFAULT NULL,
  `modtime` bigint(20) DEFAULT NULL,
  `isdel` varchar(40) DEFAULT NULL,
  `info` varchar(255) DEFAULT NULL,
  `seq` int(6) DEFAULT NULL,
  PRIMARY KEY (`type_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of boke_type
-- ----------------------------
INSERT INTO `boke_type` VALUES ('645b5b81d6ce4f6b9a74ea8a7179bc35', 'TYPE202005117550', '计算机', 'a8d54e799fa04d4f9f5f8d795638d2bd', '1589161047084', '1589161047084', '0', '', '2');
INSERT INTO `boke_type` VALUES ('9f3ab1c592414f978b45b4eb43a20504', 'TYPE202005119187', '微服务', 'a8d54e799fa04d4f9f5f8d795638d2bd', '1589161732080', '1589161732080', '0', '', '3');
INSERT INTO `boke_type` VALUES ('b4b12fb9ae6844fb865cf3344c1cc034', 'TYPE202005114587', 'java', 'a8d54e799fa04d4f9f5f8d795638d2bd', '1589162126287', '1589162126287', '0', '', '1');
INSERT INTO `boke_type` VALUES ('c2d4c6a52270449a866bd196d51eb62c', 'TYPE202005114795', '日常', 'a8d54e799fa04d4f9f5f8d795638d2bd', '1589162143258', '1589162143258', '0', '', '7');

-- ----------------------------
-- Table structure for `boke_user`
-- ----------------------------
DROP TABLE IF EXISTS `boke_user`;
CREATE TABLE `boke_user` (
  `user_id` varchar(32) NOT NULL,
  `email` varchar(40) DEFAULT NULL,
  `password` varchar(40) DEFAULT NULL,
  `user_name` varchar(40) DEFAULT NULL,
  `user_code` varchar(40) NOT NULL,
  `realname` varchar(40) DEFAULT NULL,
  `salt` varchar(40) DEFAULT NULL,
  `info` text,
  `creater` varchar(40) DEFAULT NULL,
  `createtime` bigint(20) DEFAULT NULL,
  `isdel` varchar(40) DEFAULT NULL,
  `gender` varchar(40) DEFAULT NULL,
  `tel` varchar(11) DEFAULT NULL,
  `modtime` bigint(20) DEFAULT NULL,
  PRIMARY KEY (`user_id`),
  UNIQUE KEY `code` (`user_code`),
  UNIQUE KEY `user_name` (`user_name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of boke_user
-- ----------------------------
INSERT INTO `boke_user` VALUES ('a8d54e799fa04d4f9f5f8d795638d2bd', '1975291043@qq.com', 'ddee2d611911d0753332df3753987569', '懒龙卧道', 'USER202005122701', '陈思安', '0d0ecc49c14e4378a1be85078c7117fa', null, null, '1589247996353', '0', '1', '13995971833', '1589247996353');

-- ----------------------------
-- Table structure for `file_picture`
-- ----------------------------
DROP TABLE IF EXISTS `file_picture`;
CREATE TABLE `file_picture` (
  `picture_id` varchar(32) NOT NULL,
  `picture_name` varchar(40) DEFAULT NULL,
  `suffix` varchar(20) DEFAULT NULL,
  `picture_code` varchar(40) DEFAULT NULL,
  `creater` varchar(40) DEFAULT NULL,
  `createtime` bigint(20) DEFAULT NULL,
  `isdel` varchar(40) DEFAULT NULL,
  `modtime` bigint(20) DEFAULT NULL,
  `info` varchar(500) DEFAULT NULL,
  `size` int(11) DEFAULT NULL,
  `path` varchar(500) DEFAULT NULL,
  PRIMARY KEY (`picture_id`),
  UNIQUE KEY `code` (`picture_code`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of file_picture
-- ----------------------------
INSERT INTO `file_picture` VALUES ('10c1067f27cf4c10a632d050406a10a2', '142155pwjhqnwhuk9cbsul.jpg', 'jpg', 'PICTURE202004304678', '411d5b91cfab4d4aba320a78e1a1c91f', '1588229723397', '0', '1588229723397', null, '0', 'USER202004270057/10c1067f27cf4c10a632d050406a10a2.jpg');
INSERT INTO `file_picture` VALUES ('29984bf0aa3e4fb4a19bb69b0c49debd', 'we.jpg', 'jpg', 'PICTURE202005131814', 'a8d54e799fa04d4f9f5f8d795638d2bd', '1589338001264', '0', '1589338001264', null, '0', 'a8d54e799fa04d4f9f5f8d795638d2bd/29984bf0aa3e4fb4a19bb69b0c49debd.jpg');
INSERT INTO `file_picture` VALUES ('32e1e11a93b645c28b3dce533435196c', 'woman-pretty.jpg', 'jpg', 'PICTURE202005127295', 'a8d54e799fa04d4f9f5f8d795638d2bd', '1589250602454', '0', '1589250602454', null, '0', 'a8d54e799fa04d4f9f5f8d795638d2bd/32e1e11a93b645c28b3dce533435196c.jpg');
INSERT INTO `file_picture` VALUES ('b18b1eff07c44efba966c61ba9bb18e7', '4.jpg', 'jpg', 'PICTURE202005055615', '411d5b91cfab4d4aba320a78e1a1c91f', '1588671747619', '0', '1588671747619', null, '0', 'USER202004270057/b18b1eff07c44efba966c61ba9bb18e7.jpg');
INSERT INTO `file_picture` VALUES ('d1711e848a114d7f943738a7accb02d0', 'pic6.jpg', 'jpg', 'PICTURE202005130182', 'a8d54e799fa04d4f9f5f8d795638d2bd', '1589335202987', '0', '1589335202987', null, '0', 'a8d54e799fa04d4f9f5f8d795638d2bd/d1711e848a114d7f943738a7accb02d0.jpg');
INSERT INTO `file_picture` VALUES ('d62a19c7905c4b35a1ce5028b3e3303b', 'we.jpg', 'jpg', 'PICTURE202005061332', '411d5b91cfab4d4aba320a78e1a1c91f', '1588735247695', '0', '1588735247695', null, '0', '411d5b91cfab4d4aba320a78e1a1c91f/d62a19c7905c4b35a1ce5028b3e3303b.jpg');
INSERT INTO `file_picture` VALUES ('dfc7c6e7eb1040049a9bff1c6db46882', 'pic6.jpg', 'jpg', 'PICTURE202004304646', '411d5b91cfab4d4aba320a78e1a1c91f', '1588230504074', '0', '1588230504074', null, '0', 'USER202004270057/dfc7c6e7eb1040049a9bff1c6db46882.jpg');

-- ----------------------------
-- Table structure for `sys_admin`
-- ----------------------------
DROP TABLE IF EXISTS `sys_admin`;
CREATE TABLE `sys_admin` (
  `admin_id` varchar(32) NOT NULL,
  `admin_code` varchar(40) DEFAULT NULL,
  `admin_name` varchar(40) DEFAULT NULL,
  `real_name` varchar(40) DEFAULT NULL,
  `password` varchar(40) DEFAULT NULL,
  `salt` varchar(40) DEFAULT '',
  `email` varchar(40) DEFAULT NULL,
  `tel` bigint(11) DEFAULT NULL,
  `type` varchar(40) DEFAULT NULL,
  `gender` varchar(40) DEFAULT NULL,
  `info` varchar(440) DEFAULT NULL,
  `createtime` bigint(20) DEFAULT NULL,
  `modtime` bigint(20) DEFAULT NULL,
  `isdel` varchar(40) DEFAULT NULL,
  PRIMARY KEY (`admin_id`),
  UNIQUE KEY `admin_code` (`admin_code`),
  UNIQUE KEY `admin_name` (`admin_name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of sys_admin
-- ----------------------------
INSERT INTO `sys_admin` VALUES ('27b3fc355fef4f52bbaf4b00f7c7828b', 'admin202003031087', '胡瑾', '胡瑾', '2b8f42a4e9cbb37178cd2ea6747bdd1e', 'e3f3f2d96a45425b883e9fd14f2e6ebd', '22222@qq.com', '13995971822', null, '0', null, '1583208633436', '1583843536238', '0');
INSERT INTO `sys_admin` VALUES ('2bd35989994a4f5f8024404b14790631', 'admin202003271991', '测试', 'sfse', 'a88cd67feb75d08827a232226baf0967', '22e09624676842d68813f68e9792f216', '1975291043@qq.com', '13994958233', null, '1', null, '1585275438689', '1588918230762', '0');
INSERT INTO `sys_admin` VALUES ('2e1b60e727a24a9ea7a8e6c0c9f752a5', 'admin202003033983', 'bitmap', 'bitmap', '8237622600e7d2eb65bb1403ece5cf28', 'eab49edc83d4481aa7ff226a941f7d99', '1975291043@qq.com', '13995971866', null, '1', null, '1583208461687', '1584886878874', '0');
INSERT INTO `sys_admin` VALUES ('a00c24d967db4e019ec4143580858de5', 'admin202003103600', '陈思安', '陈思安', '6300928a429d003cc79dac6eb9273a81', '4254548030e345d9963450738e93fffb', '1975432910@qq.com', '13995971833', null, '1', null, '1583843370358', '1585042573237', '0');
INSERT INTO `sys_admin` VALUES ('aab5821bf1344c16967bb69e75671ce8', 'admin202003033646', '未解之谜', 'm4a1', '5fa05a4c320fd13c5d789340e964711d', '0f6c78b9ad0b42c7983e9f5a74e1d6f0', '666666@qq.com', '13995971832', null, '1', null, '1583208926874', '1584243229032', '0');
INSERT INTO `sys_admin` VALUES ('ab8fa4abc4a94d458bcb525cd6b47dce', 'admin202003030774', '范子文', '无', '4a784be08e6f8a474f173a88710d7c9e', 'f48d2c8678bf401685dfeb68d5c5113c', '333333@qq.com', '13995971222', null, '1', null, '1583210323028', '1583844098340', '0');
INSERT INTO `sys_admin` VALUES ('b8f1cec4eb7c4982884489227c474789', 'admin202003165402', '海绵宝宝', '不叫我', '0bbbd9c50a0910e5eb56878c6eedff5e', 'a4e5edfd3826434aa128a570b836b7be', '', '13894890933', null, '0', null, '1584329051941', '1584329097989', '0');
INSERT INTO `sys_admin` VALUES ('c4fd5e04f30d4a82b0cd995131364c81', 'admin202004021767', '艾莉', '艾莉', '2ac0c9f6b625c78c98ab96015c4307d2', '45c5bacdf36e4218b42521b368f6e9c0', '1975291043@qq.com', '13994958233', null, '0', null, '1585797074172', '1585797142170', '0');

-- ----------------------------
-- Table structure for `sys_dictionary`
-- ----------------------------
DROP TABLE IF EXISTS `sys_dictionary`;
CREATE TABLE `sys_dictionary` (
  `dic_id` varchar(32) NOT NULL,
  `dic_code` varchar(40) DEFAULT NULL,
  `dic_name` varchar(40) DEFAULT NULL,
  `parent_id` varchar(32) DEFAULT NULL,
  `value` varchar(40) DEFAULT NULL,
  `dic_type` varchar(40) DEFAULT NULL,
  `info` varchar(440) DEFAULT NULL,
  `createtime` bigint(20) DEFAULT NULL,
  `modtime` bigint(20) DEFAULT NULL,
  `isdel` varchar(40) DEFAULT NULL,
  `creater` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`dic_id`),
  UNIQUE KEY `dic_code` (`dic_code`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of sys_dictionary
-- ----------------------------
INSERT INTO `sys_dictionary` VALUES ('003', 'dic_root2', '数据字典', null, 'dic_root', '1', null, null, null, null, null);
INSERT INTO `sys_dictionary` VALUES ('09e62b89c47c4485b786dff22b1abf10', 'dic202003086114', '日记', 'a6c68a0600ec4ed0a80e445b0b6a26af', 'riji', '0', '', '1583657659136', null, null, null);
INSERT INTO `sys_dictionary` VALUES ('1266932fd49a4119800ef02005b50965', 'dic202003084171', '平原', '68c0697975894302ad81f2a1c85648ae', 'pingyuan', '', '', '1583657840305', null, null, null);
INSERT INTO `sys_dictionary` VALUES ('1f1c53629fe24958b442b48a86bdcd68', 'dic202003222062', '桌面', 'a6c68a0600ec4ed0a80e445b0b6a26af', 'zhuomian', '0', '', '1584887363304', null, null, null);
INSERT INTO `sys_dictionary` VALUES ('24d646e1b0d342d589da45ba4d634130', 'dic202002254108', '明星', 'a6c68a0600ec4ed0a80e445b0b6a26af', 'star', '0', '', '1582633819278', null, null, null);
INSERT INTO `sys_dictionary` VALUES ('2d43cd35c1334bb18882b7ff959c5286', 'dic202003086464', '城市', '68c0697975894302ad81f2a1c85648ae', 'city', '0', '', '1583658202779', null, null, null);
INSERT INTO `sys_dictionary` VALUES ('31fa311b7ebc400e857936c2ff3ad36f', 'dic202003124644', '少女', '80ee54d97b3240779783eceb73ef6ee1', 'shaonv', '0', '', '1584007702839', null, null, null);
INSERT INTO `sys_dictionary` VALUES ('548c346d243648c1b36a69f9e61f38b7', 'dic202003081752', '森林', '68c0697975894302ad81f2a1c85648ae', 'trees', '0', '', '1583657565414', null, null, null);
INSERT INTO `sys_dictionary` VALUES ('68c0697975894302ad81f2a1c85648ae', 'dic202003082139', '视野', 'f32159998e9344eeb5b83a9325c79054', 'shiye', '1', '', '1583657410161', null, null, null);
INSERT INTO `sys_dictionary` VALUES ('80ee54d97b3240779783eceb73ef6ee1', 'dic202003126152', '美女', 'f32159998e9344eeb5b83a9325c79054', 'meinv', '1', '', '1584007629271', null, null, null);
INSERT INTO `sys_dictionary` VALUES ('a6c68a0600ec4ed0a80e445b0b6a26af', 'dic202003085538', '日常', 'f32159998e9344eeb5b83a9325c79054', 'richang', '1', '', '1583657469240', null, null, null);
INSERT INTO `sys_dictionary` VALUES ('b6d18976212a4a1d9ad77f9a37974eb0', 'dic202003080643', '汽车', 'fa5ddb487e6a479b909d40bf528e1ec7', 'car', '0', '', '1583657798934', null, null, null);
INSERT INTO `sys_dictionary` VALUES ('bda88ec9fefb4731a3b6261bbafe75fb', 'dic202003085286', '海洋', '68c0697975894302ad81f2a1c85648ae', 'sea', '0', '', '1583657488185', null, null, null);
INSERT INTO `sys_dictionary` VALUES ('c2f88dac4c52457d8ed4f29b6ad2483b', 'dic202003081670', '少女', 'da774e422dad4cd6aeb64b3b51f9a756', 'shaonv', '0', '', '1583657613807', null, null, null);
INSERT INTO `sys_dictionary` VALUES ('da774e422dad4cd6aeb64b3b51f9a756', 'dic202003083370', '二次元', 'f32159998e9344eeb5b83a9325c79054', 'erciyuan', '1', '', '1583657433024', null, null, null);
INSERT INTO `sys_dictionary` VALUES ('f32159998e9344eeb5b83a9325c79054', 'dic202003088260', '素材类型', '003', 'pic_type', '1', '', '1583657377585', null, null, null);
INSERT INTO `sys_dictionary` VALUES ('fa5ddb487e6a479b909d40bf528e1ec7', 'dic202003085594', '新闻', 'f32159998e9344eeb5b83a9325c79054', 'new', '1', '', '1583657783336', null, null, null);

-- ----------------------------
-- Table structure for `sys_menu`
-- ----------------------------
DROP TABLE IF EXISTS `sys_menu`;
CREATE TABLE `sys_menu` (
  `menu_id` varchar(32) NOT NULL,
  `menu_code` varchar(40) DEFAULT NULL,
  `menu_name` varchar(40) DEFAULT '' COMMENT '资源名称',
  `url` varchar(200) DEFAULT NULL COMMENT '资源URL',
  `sort` int(11) DEFAULT NULL COMMENT '排序',
  `info` varchar(440) DEFAULT '' COMMENT '备注',
  `parent_id` varchar(32) DEFAULT '' COMMENT '父菜单ID，一级菜单为0',
  `permission` varchar(40) DEFAULT '' COMMENT '授权(如：sys:user:create)',
  `type` varchar(40) DEFAULT NULL,
  `createtime` bigint(20) DEFAULT NULL,
  `modtime` bigint(20) DEFAULT NULL,
  `isdel` varchar(40) DEFAULT NULL,
  PRIMARY KEY (`menu_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='资源管理';

-- ----------------------------
-- Records of sys_menu
-- ----------------------------
INSERT INTO `sys_menu` VALUES ('001', 'menu', '资源管理', null, null, '', '', '', null, null, null, '0');
INSERT INTO `sys_menu` VALUES ('6a567d35896a41419bcd4ff193b94ea5', 'menu202002265497', '权限管理', '2', '1', '', '001', 'sys:grant', null, '1582720059003', null, null);
INSERT INTO `sys_menu` VALUES ('6efceedd8b2f43ce83822f094559225b', 'menu202003018568', '角色管理', 'role_manage.html', '2', '', '6a567d35896a41419bcd4ff193b94ea5', 'sys:grant:role', null, '1583065724246', null, null);
INSERT INTO `sys_menu` VALUES ('7d726bb833404ab0977346c6aaf4391f', 'menu202002269567', '编辑用户', '', '2', '', '83881592bdc5404b83852275262cc199', '', null, '1582712412199', null, null);
INSERT INTO `sys_menu` VALUES ('83881592bdc5404b83852275262cc199', 'menu202002264360', '管理员', '1', '1', 's', '001', '', null, '1582712301100', null, null);
INSERT INTO `sys_menu` VALUES ('e6771d2a40ad4bd39037a2877b557c81', 'caidan', '菜单管理', '', '1', '', '001', 'sys:grant:menu', null, '1583065753829', null, null);

-- ----------------------------
-- Table structure for `sys_permission`
-- ----------------------------
DROP TABLE IF EXISTS `sys_permission`;
CREATE TABLE `sys_permission` (
  `pid` varchar(32) NOT NULL,
  `permisson` varchar(40) DEFAULT NULL,
  `admin_id` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`pid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of sys_permission
-- ----------------------------

-- ----------------------------
-- Table structure for `sys_role`
-- ----------------------------
DROP TABLE IF EXISTS `sys_role`;
CREATE TABLE `sys_role` (
  `role_id` varchar(32) NOT NULL,
  `role_code` varchar(40) DEFAULT NULL,
  `role_name` varchar(40) DEFAULT NULL,
  `info` varchar(440) DEFAULT NULL,
  `isdel` varchar(40) DEFAULT NULL,
  `createtime` bigint(20) DEFAULT NULL,
  `modtime` bigint(20) DEFAULT NULL,
  PRIMARY KEY (`role_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of sys_role
-- ----------------------------
INSERT INTO `sys_role` VALUES ('13b80bb0b47845d6859a8810fb8723cb', 'role202003032048', '用户管理员', '', '0', '1583202907311', null);
INSERT INTO `sys_role` VALUES ('2dac371d48ca406db5fc0147d9c47f9d', 'role202003030260', '边缘人', '', '0', '1583202944534', null);
INSERT INTO `sys_role` VALUES ('a86d5a403aca40e696a7af3b92fca908', 'role202003032196', '学姐', '', '0', '1583202968204', null);
INSERT INTO `sys_role` VALUES ('ba235b3bf016463e8d1093cfefb5795c', 'role202003032128', '黑衣杀手', '', '0', '1583202981260', null);
INSERT INTO `sys_role` VALUES ('c4c25b098e8846ffb64029286425c15f', 'role202003035174', '超管', '', '0', '1583202914172', null);
INSERT INTO `sys_role` VALUES ('dd9bab77e4d44cdfb9fd31459d50aed8', 'role202003032117', '抽象工程师', '构建抽象架构', '0', '1583210275472', null);
INSERT INTO `sys_role` VALUES ('f0990790deb3425aa32517df23e42b85', 'role202003037376', '大佬', '', '0', '1583202994909', null);

-- ----------------------------
-- Table structure for `sys_role_admin`
-- ----------------------------
DROP TABLE IF EXISTS `sys_role_admin`;
CREATE TABLE `sys_role_admin` (
  `role_id` varchar(32) DEFAULT '' COMMENT '角色ID',
  `admin_id` varchar(32) DEFAULT '' COMMENT 'ID'
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='角色与菜单对应关系';

-- ----------------------------
-- Records of sys_role_admin
-- ----------------------------
INSERT INTO `sys_role_admin` VALUES ('f0990790deb3425aa32517df23e42b85', 'ab8fa4abc4a94d458bcb525cd6b47dce');
INSERT INTO `sys_role_admin` VALUES ('ba235b3bf016463e8d1093cfefb5795c', 'ab8fa4abc4a94d458bcb525cd6b47dce');
INSERT INTO `sys_role_admin` VALUES ('2dac371d48ca406db5fc0147d9c47f9d', 'ab8fa4abc4a94d458bcb525cd6b47dce');
INSERT INTO `sys_role_admin` VALUES ('2dac371d48ca406db5fc0147d9c47f9d', 'aab5821bf1344c16967bb69e75671ce8');
INSERT INTO `sys_role_admin` VALUES ('a86d5a403aca40e696a7af3b92fca908', 'b8f1cec4eb7c4982884489227c474789');
INSERT INTO `sys_role_admin` VALUES ('dd9bab77e4d44cdfb9fd31459d50aed8', '2e1b60e727a24a9ea7a8e6c0c9f752a5');

-- ----------------------------
-- Table structure for `sys_role_menu`
-- ----------------------------
DROP TABLE IF EXISTS `sys_role_menu`;
CREATE TABLE `sys_role_menu` (
  `role_id` varchar(32) DEFAULT '' COMMENT '角色ID',
  `menu_id` varchar(32) DEFAULT '' COMMENT 'ID'
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='角色与菜单对应关系';

-- ----------------------------
-- Records of sys_role_menu
-- ----------------------------
INSERT INTO `sys_role_menu` VALUES ('13b80bb0b47845d6859a8810fb8723cb', '83881592bdc5404b83852275262cc199');
INSERT INTO `sys_role_menu` VALUES ('13b80bb0b47845d6859a8810fb8723cb', '7d726bb833404ab0977346c6aaf4391f');
INSERT INTO `sys_role_menu` VALUES ('c4c25b098e8846ffb64029286425c15f', '001');
INSERT INTO `sys_role_menu` VALUES ('c4c25b098e8846ffb64029286425c15f', '6a567d35896a41419bcd4ff193b94ea5');
INSERT INTO `sys_role_menu` VALUES ('c4c25b098e8846ffb64029286425c15f', '6efceedd8b2f43ce83822f094559225b');
INSERT INTO `sys_role_menu` VALUES ('c4c25b098e8846ffb64029286425c15f', 'e6771d2a40ad4bd39037a2877b557c81');
INSERT INTO `sys_role_menu` VALUES ('c4c25b098e8846ffb64029286425c15f', '83881592bdc5404b83852275262cc199');
INSERT INTO `sys_role_menu` VALUES ('c4c25b098e8846ffb64029286425c15f', '7d726bb833404ab0977346c6aaf4391f');
INSERT INTO `sys_role_menu` VALUES ('a86d5a403aca40e696a7af3b92fca908', '001');
INSERT INTO `sys_role_menu` VALUES ('a86d5a403aca40e696a7af3b92fca908', '6a567d35896a41419bcd4ff193b94ea5');
INSERT INTO `sys_role_menu` VALUES ('a86d5a403aca40e696a7af3b92fca908', '6efceedd8b2f43ce83822f094559225b');
INSERT INTO `sys_role_menu` VALUES ('a86d5a403aca40e696a7af3b92fca908', 'e6771d2a40ad4bd39037a2877b557c81');
INSERT INTO `sys_role_menu` VALUES ('a86d5a403aca40e696a7af3b92fca908', '83881592bdc5404b83852275262cc199');
INSERT INTO `sys_role_menu` VALUES ('a86d5a403aca40e696a7af3b92fca908', '7d726bb833404ab0977346c6aaf4391f');
INSERT INTO `sys_role_menu` VALUES ('ba235b3bf016463e8d1093cfefb5795c', '6a567d35896a41419bcd4ff193b94ea5');
INSERT INTO `sys_role_menu` VALUES ('ba235b3bf016463e8d1093cfefb5795c', '6efceedd8b2f43ce83822f094559225b');
INSERT INTO `sys_role_menu` VALUES ('ba235b3bf016463e8d1093cfefb5795c', 'e6771d2a40ad4bd39037a2877b557c81');
INSERT INTO `sys_role_menu` VALUES ('dd9bab77e4d44cdfb9fd31459d50aed8', 'e6771d2a40ad4bd39037a2877b557c81');
INSERT INTO `sys_role_menu` VALUES ('2dac371d48ca406db5fc0147d9c47f9d', '6a567d35896a41419bcd4ff193b94ea5');
INSERT INTO `sys_role_menu` VALUES ('2dac371d48ca406db5fc0147d9c47f9d', '6efceedd8b2f43ce83822f094559225b');
INSERT INTO `sys_role_menu` VALUES ('2dac371d48ca406db5fc0147d9c47f9d', 'e6771d2a40ad4bd39037a2877b557c81');

-- ----------------------------
-- Function structure for `fn_fixNum`
-- ----------------------------
DROP FUNCTION IF EXISTS `fn_fixNum`;
DELIMITER ;;
CREATE DEFINER=`root`@`localhost` FUNCTION `fn_fixNum`(`maxNum` bigint,`len` int) RETURNS varchar(40) CHARSET utf8
BEGIN
	#设置指定长度的数字编号
	DECLARE codeString VARCHAR(40) DEFAULT '';
	DECLARE i INT DEFAULT 1;

	WHILE i<len-LOG10(maxNum) DO
		SET codeString=CONCAT(codeString,0);
		SET i=i+1;
	END WHILE;

	RETURN CONCAT(codeString,maxNum);
END
;;
DELIMITER ;

-- ----------------------------
-- Function structure for `fn_generateCode`
-- ----------------------------
DROP FUNCTION IF EXISTS `fn_generateCode`;
DELIMITER ;;
CREATE DEFINER=`root`@`localhost` FUNCTION `fn_generateCode`(`type` varchar(40)) RETURNS varchar(40) CHARSET utf8
BEGIN
	#记录code的生成方案
	#定义一个变量装载生成的code
	DECLARE codeString VARCHAR(40) DEFAULT '';
	DECLARE nowDay VARCHAR(40) DEFAULT '00000000';
	#定义最大记录数
	DECLARE maxNum BIGINT DEFAULT 1;
	#year(CURRENT_DATE),month(CURRENT_DATE),day(CURRENT_DATE)
	#now()函数可以返回一个格式化的字符串，从第一个字符截取10个
	SET nowDay=SUBSTRING(CONCAT(NOW(),''),1,10);

	#判断code类型
	if type='USER' THEN
		SET codeString='USER';
		SELECT count(1)+1 INTO maxNum FROM boke_user WHERE createtime LIKE CONCAT(nowDay,'%');
	ELSEIF type='BOKE' THEN
		#boke春秋
		SET codeString='CQBOKE';
		SELECT count(1)+1 INTO maxNum FROM boke_boke WHERE createtime LIKE CONCAT(nowDay,'%');
	ELSEIF type='SPECIAL' THEN
		#专辑
		SET codeString='SPECIAL';
		SELECT count(1)+1 INTO maxNum FROM boke_special WHERE createtime LIKE CONCAT(nowDay,'%');
	ELSEIF type='PICTURE' THEN
		#boke春秋
		SET codeString='PICTURE';
		SELECT count(1)+1 INTO maxNum FROM file_picture WHERE createtime LIKE CONCAT(nowDay,'%');
	ELSEIF type='ADMIN' THEN
		#boke春秋
		SET codeString='ADMIN';
		SELECT count(1)+1 INTO maxNum FROM sys_admin WHERE createtime LIKE CONCAT(nowDay,'%');
	END IF;

	#替换字符里面的'-'为空字符串
	SET nowDay=REPLACE(nowDay,'-','');
	RETURN CONCAT(codeString,nowDay,fn_fixNum(maxNum,6));
END
;;
DELIMITER ;

-- ----------------------------
-- Function structure for `fn_uuid32`
-- ----------------------------
DROP FUNCTION IF EXISTS `fn_uuid32`;
DELIMITER ;;
CREATE DEFINER=`root`@`localhost` FUNCTION `fn_uuid32`() RETURNS varchar(32) CHARSET utf8
BEGIN
	#32位uuid生成方案
	RETURN REPLACE(UUID(),'-','');
END
;;
DELIMITER ;
